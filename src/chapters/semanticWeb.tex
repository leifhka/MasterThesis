
\chapter{Semantic Web \& OTTR}

\section{RDF}
\label{rdf}

\section{OWL}

\section{SPARQL}
\emph{SPARQL}\cite{SPARQL} enables querying over RDF graphs. SPARQL has several similarities to SQL for Relation Databases, such as the SELECT and WHERE clause. The WHERE-clause contains a graph pattern, a set of RDF-tripels, that SPARQL searches for in the RDF graphs. In addition, the graph pattern can contain variables denoted \lstinline{?variableName}, which is the resources that SPARQL extracts. Furthermore, the SELECT lets us select which variables we want to obtain and return their bindings. Applying SELECT * will return all the variables used in the WHERE clause.

\para
As an example, we utilise the same ontology about families used in section \ref{rdf}.  Additionally, the ontology now also contain the relation ex-r:lifeStage, a relation from a person to the person's life stage, e.g. child. All the examples in this section will query over the following graph: 

\para
\begin{lstlisting}[frame=single, language=turtle, frame=none]
@prefix  ex-p:  <http://example.org/person/> . 
@prefix ex-r:  <http://example.org/relation/> . 

_:person1 ex-r:hasAge 17;
    ex-r:hasName "Sofie";
    ex-r:hasLifeStage ex-p:Teenager.

_:person2 ex-r:hasAge 16;
    ex-r:hasName "Harry";
    ex-r:hasFather ex-p:Noah;
    ex-r:hasLifeStage ex-p:Teenager.

ex-p:Noah ex-r:hasAge 47;
    ex-r:hasName "Noah";
    ex-r:hasFather ex-p:Fred;
    ex-r:hasLifeStage ex-p:Adult. 

ex-p:Fred  ex-r:hasName "Fred";
    ex-r:hasLifeStage ex-p:Retired. 
\end{lstlisting}

\para
The following is a SPARQL query that retrieves every person with an age and a name. 

\para
\begin{lstlisting}[frame=single, language=turtle, frame=none]
PREFIX  ex-p:  <http://example.org/person/> 
PREFIX ex-r:  <http://example.org/relation/> 

SELECT *
WHERE{
    _:person ex-r:hasName ?name;
            ex-r:hasAge ?age.
}
\end{lstlisting}

\para
The SPARQL query above results in the following table. 

\para
\begin{tabular}{@{}cc@{}}
    \toprule
    name & age  \\ \midrule
    Sofie & 17 \\ 
    Harry & 16 \\ 
    Noah  & 47 \\ \bottomrule
\end{tabular}

\para 
In addition, SPARQL introduces the UNION pattern. Graph patterns can utilise UNION between them, combining them, resulting in SPARQL extracting the results in all graph patterns. An example of using UNION is to extract the name of every person that is either in the old or teenager life stage.

\para
\begin{lstlisting}[frame=single, language=turtle, frame=none]
PREFIX  ex-p:  <http://example.org/person/> 
PREFIX ex-r:  <http://example.org/relation/> 

SELECT ?name
WHERE{
    {
        ?person ex-r:hasName ?name;
            ex-r:hasLifeStage ex-p:Teenager.

    } UNION {
        ?person ex-r:hasName ?name;
            ex-r:hasLifeStage ex-p:Retired.

    }
}
\end{lstlisting}

\para
\begin{tabular}{@{}cc@{}}
    \toprule
    name & \\ \midrule
    Sofie \\ 
    Harry \\ 
    Fred  \\ \bottomrule
\end{tabular}


\para
Additionally, SPARQL introduces FILTER. FILTER is a clause we can use to filter the result. Furthermore, the OPTIONAL clause allows us to construct an optional graph pattern that may be there, although the pattern is not required.

\para
Extracting every person's name and age if the person is under 18, in addition, to the father if the person has a father, would look like this and would yield   the following result:

\para
\begin{lstlisting}[frame=single, language=turtle, frame=none]
PREFIX  ex-p:  <http://example.org/person/> 
PREFIX ex-r:  <http://example.org/relation/> 

SELECT ?name ?age ?father
WHERE{
    ?person ex-r:hasName ?name;
            ex-r:hasAge ?age.

    FILTER(?age < 18)
    OPTIONAL{
        ?person ex-r:hasFather ?father.
    }
}
\end{lstlisting}

\para
\begin{tabular}{@{}ccc@{}}
    \toprule
    name & age & father \\ \midrule
    Sofie & 17 & \\ 
    Harry & 16 & http://example.org/person/Noah\\ \bottomrule
\end{tabular}


\para
SPARQL 1.1\cite{SPARQL1.1} is an expansion to SPARQL, introducing, among other things, aggregation, negation, BIND, and property paths. Firstly, aggregation makes it possible to group the result with the clause GROUP BY. Furthermore, the HAVING-clause operates over grouped sets, resulting in the possibility to filter on the sets. Secondly, negation or the NOT EXISTS clause contains a graph pattern of RDF-tripels that should not be present in the graph pattern. Thirdly, SPARQL 1.1 offers BIND a way to bind a variable to a value. Lastly, property paths open up the opportunity to route specific paths of properties between two resources. There are numerous different types of property paths, such as SequentPath denoted with an /. Using the SequentPath, one can define several properties after each other with /. An example of usage of the SequentPath is to find all the names of all fathers, which we can write as \lstinline{?person ex-r:hasFather/ex-r:hasName ?fatherName} in the WHERE clause. The SPARQL 1.1 Query Language document presents a full table of all the varieties of properties paths.

\para
As an example of aggregation, the subsequent SPARQL query results in the number of persons in each life stage if there is more then 1 person in it. 

\begin{lstlisting}[frame=single, language=turtle, frame=none]
PREFIX  ex-p:  <http://example.org/person/> 
PREFIX ex-r:  <http://example.org/relation/> 

SELECT ?stage (COUNT(?person) AS ?persons)
WHERE{
    ?person ex-r:lifeStage ?stage.
}
GROUP BY ?stage
HAVING COUNT(?person) > 1
\end{lstlisting}
    
\para
\begin{tabular}{@{}cc@{}}
    \toprule
    stage & persons  \\ \midrule
    http://example.org/person/Teenager & 2 \\ \bottomrule
\end{tabular}

\para
Additionally, an example of using BIND is finding the names of persons and their fathers and displaying how old the father was when the person was born.
\begin{lstlisting}[frame=single, language=turtle, frame=none]
PREFIX  ex-p:  <http://example.org/person/> 
PREFIX ex-r:  <http://example.org/relation/> 

SELECT ?name ?fatherName ?fathersAgeAtBirth
WHERE{
    _:person ex-r:hasName ?name;
            ex-r:hasAge ?age;
            ex-r:hasFather [ex-r:hasName ?fatherName;
                            ex-r:hasAge ?fatherAge].
    BIND(?fatherAge - ?age AS ?fathersAgeAtBirth)
}
\end{lstlisting}
    
\para
\begin{tabular}{@{}ccc@{}}
    \toprule
    name & fatherName & fathersAgeAtBirth \\ \midrule
    Harry & Noah & 31\\\bottomrule
\end{tabular}



\para
In addition to SELECT, SPARQL offers several other queries:
\begin{itemize}
    \item \textbf{CONSTRUCT}: Returns a new RDF graph. The Construct clause contains a graph pattern that applies the variables from the WHERE clause to create the new RDF graph. 
    \item \textbf{ASK}: Returns either yes or no. Yes, if the query pattern has a solution, no otherwise. 
    \item \textbf{DESCRIBE}: Returns an RDF graph containing data about the resource. 
    \item \textbf{DELETE}: Deletes everything that matches the given graph pattern 
    \item \textbf{INSERT}: Works as CONSTRUCT but instead of making a new graph
\end{itemize}
Additionally, there are various other queries in the SPARQL 1.1 update language for RDF\cite{SPARQL1.1Update}, including the DELETE and INSERT queries.  

\section{SHACL}

The RDF Data Shape Working group had a goal
\begin{quotation}
    ...to produce a language for defining structural constraints on RDF graphs. In the same way that SPARQL made it possible to query RDF data, the product of the RDF Data Shapes WG will enable the definition of graph topologies for interface specification, code development, and data verification.\autocite{Shape_working_group}
\end{quotation}
Which resulted in, among other things, the Shape Constraint Language(SHACL)\autocite{SHACL} . SHACL consists of two main parts SHACL core and SHACL SPARQL; in this section, we will solely focus on the foremost. SHACL takes in two inputs, an RDF data graph and a shape graph also written in RDF. Shapes are "conjunctions of constraints that a node most satisfy."\autocite[FIND PAGE]{SHACL_BOOK}. SHACL goes through the data graph and checks if the constraints provided in the shape graph are satisfied, returning a validation report in RDF, which primarily contains the property sh:conforms linking the report to a boolean value. The boolean value is true if the graph does conform to the shapes, otherwise false. 

\para 
SHACL partitions the shapes into two main types node shape and property shape. Firstly, a node shape consists of constraints directed at a focus node.  A focus node or target can be specified in specific ways, targeting all instances of a particular class\footnote{Denoted with the property sh:targetClass}, all nodes that are the subject\footnote{Denoted with the property sh:targetSubjectOf} or object\footnote{Denoted with the property sh:targetObjectOf} of a predicate, or, lastly, directly pointing to a node\footnote{Denoted with the property sh:targetNode}. Furthermore, a node shape usually contains one or more property shapes. A property shape is a constraint directed towards the values that a focus node can reach through a specified property or property path\footnote{Property paths in SHACL are a subset of the property path in SPARQL. The full list of property graphs are available in the SHACL W3C recommendation document\autocite{SHACL}}.  SHACL has the property sh:path to target the property or property path we are after.  

\para
Moreover, SHACL makes it possible to restrict the maximum and minimum numbers of distinct nodes often used to constrain how many relations of the path a focus node can have. 

\para
In the next two examples, SHACL performs validation on the following graph:
\begin{lstlisting}[frame=single, language=turtle, frame=none]
    @prefix  ex-p:  <http://example.org/person/> . 
    @prefix ex-r:  <http://example.org/relation/> . 

    ex-p:Noah a ex-p:Person;
        ex-r:hasAge 47;
        ex-r:hasName "Noah".

    ex-p:Fred a ex-p:Person;
        ex-r:hasAge 233352;
        ex-r:hasName "Fred".
\end{lstlisting}

\begin{example}
A SHACL shape that validates that every person has a name and exactly one age
\end{example}

\begin{lstlisting}[frame=single, language=turtle, frame=none]
    @prefix  ex-p:  <http://example.org/person/> . 
    @prefix ex-r:  <http://example.org/relation/> . 
    @prefix sh:	<http://www.w3.org/ns/shacl#> .

    ex-p:PersonShape a sh:NodeShape;
        sh:targetClass ex-p:Person;
        sh:property [sh:path ex-r:hasAge; 
                    sh:maxCount 1;
                    sh:minCount 1;
                    sh:name "Age";
                    sh:message "Every person needs a age"],
                    [sh:path ex-r:hasName;
                    sh:minCount 1].
\end{lstlisting}
Resulting in the following validation report:
\begin{lstlisting}[frame=single, language=turtle, frame=none]
    [] a sh:ValidationReport;
        sh:conforms true .
\end{lstlisting}

\para
Furthermore, SHACL contains constraint components that define a set of values a node can have. These components can, among other things, specify that the node needs to be a blank node, an IRI, have a particular value, be an instance of a class, or be a literal. We can also specify what kind of data type the literal must be. Additionally, SHACL provides us with several built-in constraint components for the different data types, such as sh:minInclusive and sh:maxInclusive for numbers and  sh:pattern and sh:maxLength for strings.

\begin{example}
A SHACL shape validates that every person has exactly one age with a positive integer no bigger than 130.  Additionally,  that there is at least a name that is a string.
\end{example}

\begin{lstlisting}[frame=single, language=turtle, frame=none]
    @prefix  ex-p:  <http://example.org/person/> . 
    @prefix ex-r:  <http://example.org/relation/> . 
    @prefix sh:	<http://www.w3.org/ns/shacl#> .

    ex-p:PersonShape a sh:NodeShape;
        sh:targetClass ex-p:Person;
        sh:property [sh:path ex-r:hasAge; 
                    sh:maxCount 1;
                    sh:minCount 1;
                    sh:name "Age";
                    sh:message "Every person needs a age"],
                    [sh:path ex-r:hasName;
                    sh:minCount 1].
\end{lstlisting}
Resulting in the following validation report:\footnote{Note that we can make a personalised sh:resultMessage with the use of sh:message}
\begin{lstlisting}[frame=single, language=turtle, frame=none]
    [] a sh:ValidationReport;
        sh:conforms false;
        sh:result [
            a sh:ValidationResult ;
            sh:resultSeverity sh:Violation ;
            sh:sourceConstraintComponent sh:MaxInclusiveConstraintComponent ;
            sh:focusNode ex-p:Fred ;
            sh:value 233352 ;
            sh:resultPath ex-r:hasAge ;
            sh:resultMessage "Every person needs a age that is between 0 and 130" ;
        ] .        
\end{lstlisting}
The validation report returns a validation since ex-p:Fred has an ancient age.

\section{OTTR}
\label{OTTR}
\emph{Reasonable Ontology Templates} OTTR is a language representing ontology modelling patterns as parameterised ontologies and can make user-defined abstractions to recurring modelling patterns \autocite[477]{SLKF_OTTR_2018}. OTTR has two central constructors, \emph{templates} and \emph{instances} \autocite[3]{SLKK_OTTR_2021}. The OTTR  templates consist of a head and a body, where the head specifies a templates' name and parameters, whereas the body contains the parameterised ontology pattern \autocite[479]{SLKF_OTTR_2018}. In addition, OTTR allows us to determine the types, which \autoref{ottr types} discusses, and the cardinality of the parameters. There are two types of cardinalities \emph{mandatory} or \emph{optional}. Optional is denoted with a ? while mandatory is the default. An optional parameter allows that the corresponding argument is none \footnote{None (denoted with ottr:none) is a value in the OTTR framework used to represent a missing or no value \autocite[7]{SLKK_OTTR_2021}, similar to, for example, NULL in Java}. Furthermore, a parameter can also have a specified \emph{default value}, which can be any valid argument. If an instance argument is none on a corresponding mandatory parameter during the expansion, OTTR ignores the instance\autocite[480]{SLKF_OTTR_2018}. However, if the parameter has a default value, then OTTR uses this default value instead of none \autocite[7]{SLKK_OTTR_2021}. In addition, a parameter can be \emph{non-blank}, meaning that it cannot take in a blank node. We can denote a \emph{non-blank} paramter using !\autocite[6]{SLKK_OTTR_2021}.

\para
Instances, also called template instances, represents the use of a template.  Instances contain the name of the template it uses and a list of its arguments that substitute the template's parameters \autocite[3]{SLKK_OTTR_2021}. To build up the parameterised ontology pattern in the body, we use instances of templates and base templates \autocite[479]{SLKF_OTTR_2018}. \emph{Base templates} are a particular type of template that may not contain a pattern that often represents an abstraction in an underlying language. Since OTTR's underlying langue is RDF, one critical base template is ottr:Triple, representing a single RDF triple \autocite[4]{SLKK_OTTR_2021}. ottr:Triple takes in three arguments: a subject, a predicate and an object, respectively. OTTR uses recursion to expand the instances into RDF graphs, recursively replacing all the instances in the body with the pattern they represent. The recursion stops when it reaches a base template \autocite[479]{SLKF_OTTR_2018}.

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{stOTTRExample.png}
    \caption{A genralisation showing the syntax of stOTTR}
    \label{fig:stOTTERGenralisation}
\end{figure}

\para
OTTR has two serialisations describing the templates and the instances: stOTTER and wOTTR. stOTTER is custom serialisation of OTTR, made to be compact and easy to ready for humans \autocite[4]{SLKK_OTTR_2021}. wOTTR, on the other hand, is a serialisation written in RDF, specified by an OWL ontology and a grammar set by SHACL \autocite{SHACL} \autocite[4]{SLKK_OTTR_2021}. In addition to the two serialisations, OTTR also provides two solutions for making instances from structure data sources; bOTTR and tabOTTR. tabOTTR is a markup language that can create instances from tabular data files, and bOTTR can make mappings over several queryable sources\autocite[16]{SLKK_OTTR_2021}. \autoref{fig:stOTTERGenralisation} shows a generalisation of OTTR written in the seralisation stOTTR.

\para
OTTR provides three different expansion modes. We can use the expansions modes on an instance in a template body. OTTR will treat every argument in an instance that has an expansion mode as a list. However, OTTR will only expand the arguments marked with the list expansion, ++, in front of the argument. Additionally, OTTR will treat arguments without a list expansion as a list with one element. Note that the different list expansions behave the same if we only mark one argument with the list expansion \autocite[480]{SLKF_OTTR_2018}. The three different expan modes works as following \autocite[8]{SLKK_OTTR_2021}:
\begin{itemize}
    \item cross: gives one instance per element in the cross-product
    \item zipMin: makes one instance per element in the smallest list, making n instances, where n is the length of the smallest list, and connecting the element on the same index in the lists
    \item zipMax: almost the same as zipMin, but instead of choosing the smallest list, zipMax makes one instance for every element in the largest list. OTTR will then append none at the end of the smaller lists until they are the same size as the largest list. 
\end{itemize}

\begin{figure}
    \begin{example}
        A OTTR template modelling a person with the same properties as in section \ref{rdf}. The result of expanding the instances on the bottom would be the same as shown in figure X (RDF SECTION)
    \end{example}
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/semanticWeb/OTTRExample.ottr}
\end{figure}


\subsubsection{Types in OTTR}
\label{ottr types} 
OTTRs type system is there to verify the correctness of the template and instances by checking for compatible typing and consistent typing. OTTRs type system has three different types of types: basic types, LUB-types and list types. Furthermore, OTTR arranges the types in a subtype relationship, where the set of types are transitive and reflexive. The opposite or inverse of a subtype is a supertype. All the basic types, except for ottr:IRI and ottr:Bot, are common types taken from RDF, RDFS, OWL and XSD standards. ottr:IRI reference to the URI to a resource. ottr:Bot represents the type Bot, a subtype to all other types. In contrast to Bot, OTTR has the type Top, rdfs: Resource, a supertype for all other types.  Top is the default parameter type. If we want the parameter to have another type, we need to add the type before the parameter name explicitly. OTTR throws an error if an argument does not have a compatible type required by the template parameter. A compatible type to a parameter is either the type that the parameter explicitly states or its subtypes. In general, a type P is compatible with all supertypes of P.

\para
\emph{LUB} (LUB<>), denoted with ottr:Lub, stands for least upper bound. For every basic type P, there is also a LUB-type LUB<P> such that LUB<P> is a subtype of P. Furthermore, LUB<P> is compatible with all subtypes of P. While P, on the other hand, is compatible with all supertypes of P. Furthermore, OTTR has two different types, \emph{List<>}, denoted with rdf:list, and \emph{NEList<>}, denoted with ottr:NEList. Where NEList stands for non-empty list. The OTTR type system assumes that for each type P, in the set of types, there exists a type List<P> and NEList<P>.  \autocite[5]{SLKK_OTTR_2021}.

\para
OTTR uses two types of type checking \emph{compatible typing} and \emph{consistent typing}. Compatible typing refers to an argument having a compatible type for the given parameter. Consistent typing, on the other hand, ensures that the parameter is consistently typed. For example, if we have a blank node, which can be any type, and we use that blank node in an instance that excepts an xsd:integer. OTTR will then interpret the blank node as an xsd:integer in the rest of the template, which means sending this blank node as an argument to an instance that expects a xsd:string will result in an error message \autocite[5-6]{SLKK_OTTR_2021}. 

\subsubsection{Terms}
Terms in OTTR are the set of constants and variables where constants include lists, an order collection of terms. In addition to the constant nil, which OTTR uses to denote an empty list. The terms in OTTR are equal to valid RDF terms, such as IRIs, blank nodes, and literals. The only distinction between a variable and a constant term is in the template definition, where the variable occurs in a parameter declaration in the template's signature.\autocite{OTTR_mOTTR}
