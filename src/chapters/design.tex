
\chapter{Design} %can also be named discussion
OTTR proposes various benefits, such as abstraction and Separation of design and content. However, we suggest that appending a programing language, Frog, that makes it feasible to manipulate terms to OTTR will strengthen several benefits, as previously discussed.  In this chapter, we will discuss how the design of Frog.

\para 
In short, Frog will be a purely typed functional programming language, resulting in Frog only allowing pure functions. The advantage of Frog being pure is that Frog can utilise memorisation on the functions. Section X (Evaluation) discusses why memorisation is an advantage in Frog. In addition to being pure, Frog will additionally be a typed language, resulting in the function explicitly stating the type of its parameters and return type. OTTR requires Frog to be typed as OTTR needs to know the type of a given term to perform validation of templates and instances, which OTTR performs before expanding the instances, implying that Frog must confirm a Functions return type. Section Y (Validation) further elaborates on the necessity of Frog being typed. 

\para
The following prefixes will be utlised in the examples of this chapter:
\lstinputlisting[language=turtle, firstnumber = 1]{examples/Frog/prefixesDesign.ttl}


\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{programFlowDesign.jpg}
    \caption{The basic flow of the program}
    \label{fig:basic_program_flow}
\end{figure}

\section{Overview}
The addition of Frog to OTTR will introduce two new possibilities. Firstly, to make a personalised function that manipulated terms, and lastly, use these functions in the template body, named a function call. A function call will execute a function for some arguments, replacing the function call with a term. Therefore, a function call is treated as a term in OTTR and Frog, where the type is the return type of the function the function call executes. In addition, OTTR and Frog will handle a Frog function as a term. However, there is no natural type for a Frog function; as a result, we introduce a new type to the OTTR type system, the Function type. Section \ref{extension_ottr_type} goes in-depth on the new Function type. 

\para
A Frog function is constructed in two parts, the function head and the function body. The function body defines what the function does under execution and consist of only one element, a function call. On the other hand, the function head specifies the function IRI, parameters, return type and the generic arguments. The function IRI is an IRI to identify the function uniquely; in other words, the function name. Furthermore, the function body can consist of parameters. However, it is feasible to make a function containing an empty set of parameters. As Frog is typed, a parameter consists of a variable and a type. The variable represents a constant, which the function body can utilise as an argument or a function if the type of the variable is consistent with a function type. Moreover, the type is the type of the variable, which Frog utilises to perform validation.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{FunctionAndFunctionCall.jpg}
    \caption{The strucure of functions and function calls}
    \label{fig:functionCall_and_function}
\end{figure}

\para
Additionally, the Function head specifies a possibly empty set of generic parameters, consisting of a variable and a type, much like an ordinary parameter. However, in this case, the variable depicts a type, and the type represents a subtype relationship between the variable and the type. A generic variable can be occurring in a or as a parameter type, a return type and a generic argument in the function body. Lastly, the function head specifies the return type, representing the type of the value that the function returns. The return type needs to be compatible with the return type of the function body. 

\para
Furthermore, a function call consists of a function IRI, arguments and generic arguments. The function IRI defines which functions for a set of arguments and generic arguments Frog should execute. An argument can be a constant or parameter variable, which must be compatible with the function's associated parameter. In contrast, a generic argument can either be a generic variable or a type compatible with the function's affiliated generic parameter. Note that both the arguments and generic arguments may be empty. Figure \ref{fig:functionCall_and_function} is a visual representation of a function and a function call structure. 

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.3]{term.png}
      \caption{Term}
      \label{fig:term}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.3]{type.png}
      \caption{frog types}
      \label{fig:type}
    \end{minipage}
\end{figure}

\para
Compared to OTTR, Frog's terms will be equal since functions and function calls will become valid terms in OTTR; consequently, functions and function calls valid terms in Frog. Figure \ref{fig:term} illustrates what a term is in Frog. On the other hand, types have a difference between OTTR and Frog, namely generic types. Generic types will only be available in Frog. Hence the types in Frog will consist of all the types in OTTR in addition. Figure \ref{fig:type} depicts a Frog type. Note that when we talk about types in this chapter, we talk about Frog types if not specified.

\para
Furthermore, there are two types of functions in Frog, base function and a Frog function. However, a Frog user will only make frog functions but can utilise both base functions and Frog functions the same way in function calls. Base functions will be a combination of XPath[source link] functions, which will operate on some of the base types, and built-in java functions that will work on the complex types, such as the list types. Indifference to a normal Frog function, the function body of a base function will not contain a function call, but a rule which is an IRI reference either the XPath function or the built-in java function. An example of base functions are operators, such as addition and divide. 

\section{Syntax}
Section 3.5 introduced OTTRs two serialisations, wOTTR and sTOTTR. As described by Skj√¶veland et al., stOTTR is made to be a serialisation of OTTR, which is easy for humans two read and write, in addition to being compact\autocite[4]{SLKK_OTTR_2021}. On the other hand, the wOTTR serialisation offers the benefit of leveraging the existing W3C stack, in addition to tools for developing, publishing and maintaining templates\autocite[481-482]{SLKF_OTTR_2018}. Consequently, we propose that Frog also provides two serialisations.

\para
As a consequence of Frog being a part of OTTR and the benefits that wOTTR offers, we propose Frog likewise have an RDF serialisation. Since wOTTR already benefits from leveraging the existing W3C stack, we need to preserve this benefit when adding Frog. For wOTTR to preserve the property of leveraging the W3C stack, everything wOTTR utilises, in this case, Frog, should a possibility of preserving it.  Additionally, wOTTR is the proposed serialisation of OTTR for publishing temp. Hence it will be reasonable to assume when publishing OTTR templates in wOTTR that the Frog functions utilised by the templates are published among the templates in the same format.  

\para
However, utilising RDF comes with its challenges as RDF requires the RDF Frog serialisation to store the information about the functions in triples; Resulting in much metadata that is not necessarily needed for a human to understand. Writing and reading the metadata may also be tedious, mainly because it requires much repetition when writing several functions. The problem of repetition in RDF is a known one as this is one of the problems that Frog tries to improve. Hence one solution could be to make a template to build a function. However, we propose a second compact serialisation, such as stOTTR, that is easy to read and write. 

\para
We suggest that there is a significant benefit to making an own human-readable serialisation of Frog compared to using an OTTR template to produce the function in RDF, besides it is nice to have a syntax for Frog that matches stOTTR, namely that the serialisation will make it easier for programmers that do not have knowledge of OTTR or RDF to make and produce functions that the OTTR templates can utilise, which means that the serialisation opens of for more people to make functions. However, this claim is only valid if the syntax is easy to learn. Hence, we need to make a syntax that is relatively easy to learn for an experienced programmer. 

\para 
To summarise, Frog will, as OTTR, have two serialisations, one written in RDF and one more compact and easy to read and write. 

\subsection{OTTR seralisations compared to Frog (?)}

\para 
A function call will have a similar syntax in RDF and the Human Readable syntax. LISP languages such as Scheme have inspired the syntax of the function calls, implying that the function IRI and the arguments are in the same list. On the one hand, the advantage of using function calls as a list of function IRI and arguments is that lists are an existing and known data structure in RDF. On the other hand, the disadvantage of utilising lists as function calls is that in the RDF syntax, a list may have several meanings \lstinline{(fn:plus 2 3)} can be the list with the elements \lstinline{fn:plus}, \lstinline{2}, and \lstinline{3} or the function call on the fn:plus function that will add the numbers 2 and 3 together. Section \cite{RDF_syntax} further discusses the issue and present a solution.

\para 
The following two subsections will present the two different syntaxes in detail. They will both present an example of the function that takes a degree in Fahrenheit and returns the degree converted to Celcius. Equal to the following function in java. 

\subsection{RDF Syntax}
\label{RDF_syntax}

\begin{figure}[b]
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/Frog/rdfSyntaxExample.ttl}
    \caption{An example of a Frog function that converts Fahrenheit to Celcius using the RDF turtle syntax}
    \label{fig:rdf_example}
\end{figure}

\para
The RDF syntax is written in the turtle serialisation and is as OTTR defined by a set of SHACL shapes expressions. Frogs RDF syntax will take a lot from the wOTTR serialisation of OTTR, for instance, the definition of terms and types, meaning that these will be equal in Frog and wOTTR. 

\para
The syntax is built up of the following parts: 

\begin{itemize}
    \item \lstinline{:Function} : For Frog to interpret an IRI as a function, we need to explicitly state that the type of the IRI is a Function. 
    \item \lstinline{:type} defines the type of the function, and is a relation between a function IRI and a blank node representing the type.
    \item \lstinline{:returnType} defines a function's return type and relates the blank node representing the type to a type. 
    \item \lstinline{:parameterTypes} defines the types of the parameters and relates the blank node representing a potentially empty list containing the types to the parameters.
    \item \lstinline{:def}
    \item \lstinline{:lambda}
    \item \lstinline{:functionCall} defines that Frog should interpret the list as a function call. Need to be placed in the start at the list. 
    \item \lstinline{:varType} defines that Frog should interpret the list as a list of generic arguments. \lstinline{:varType} need to be placed at the start of the list. If the list of generic arguments is present Frog demands the list to be right after the function IRI. 
  
\end{itemize}

\para 
IDEAS:
\begin{itemize}
    \item example 
    \item explenation of how the syntax is build up
    \item defined by a set of SHACL shapes 
    \item needs use of list to make sure that a frog function can end-up in a base template, resulting in that we need to expand the function into RDF. 
    \item a RDF list can now have several meanings it can be a list og terms, a function call, or a list of generic arguments. We need to somehow seprete what is what therefore we make the list which is functionCall with :functionCall, :typeVars for generic argument lists and nothing for normal list as they need to have the same syntax as the rest of the RDF "world"
    \item argument for use of frog:functionCall
    \begin{itemize}
        \item easier 
        \item less error-prone
        \item one IRI can have several meanings, can be the literal IRI og refer to the function letting the user define the meaning will make it possible to write better and more concret error messages and not preform the wrong operation. There is no way for us to know if (fn:contcat fn:minus fn:divide) is a list of IRIS or a functioncall with fn:minus and fn:divide as arguments. Since lists and function calls in Frog will look equal 
    \end{itemize}
\end{itemize}

\subsection{Human Readable Syntax}

\begin{figure}[h]
    \lstinputlisting[language=frog, firstnumber = 1]{examples/Frog/hrsExample.frog}
    \caption{An example of a Frog function that converts Fahrenheit to Celcius using the Human Readable syntax}
    \label{fig:hrs_example}
\end{figure}

\begin{itemize}
    \item example 
    \item explenation of how the syntax is build up
    \begin{itemize}
        \item LISP 
        \item OTTR 
    \end{itemize}
\end{itemize}

\section{Extension of the OTTR type system}
\label{extension_ottr_type}
\begin{itemize}
    \item Introduce the problem that Frog propoce with regards the OTTR type system 
    \item A function can be a parameter to a template and a argument to an instance (only the IRI to the function, we need to know if the IRI should be interpreted as a function or an IRI)
    \item Give a informal presentation of the frog type 
    \item Refer to section about OTTR type system and how it is there to varify compatible typing and consisting typing. The newly introduced Function type also needs to ensure this. A function is compatible with  another function if it's a subtype of the other function.
    \item A function F is a subtype of a function G if all the parameters on a given index in F is a supertype of the parameter on the same index in G. Additionaly the return type of F needs to be a subtype of G.
\end{itemize}

NB:Note that the Function type will be a subtype of 

\para
Section X (4.1) mentions that Frog introduces two new terms, functions and function calls. The function call term will not cause a problem since it, as previously mentioned, gets the type of the function it executes return type. However, we have not specified the type of a function term and the reason for that is that the function term introduces a new type, the function type.  

\para
The motivation to introduce functions as terms and with an own type is several. Firstly, we wish for Frog to be a high-order programming language; as a result, Frog needs to be able to take in functions as parameters and as the return value.  With the premise that Frog is a high-order language and a typed language, a function needs its type. Secondly, adding a function type makes it possible to use functions as parameters and arguments in  OTTR templates. Lastly, when a function is used as a term, it is represented with its function IRI. Therefore fn:plus could be interpreted as an IRI or the function that takes in two numbers and add them together. 

\subsection{Formal definition}
OTTR needs one additional type when introducing Frog, namely \emph{the Function type}. The Function type takes in other types as arguments. In the \textbf{Function<$T_1$,...,$T_n$>},\textbf{ $T_1$,...,$T_{n - 1}$} is the type of the function parameters, and \textbf{$T_n$} is the type of the functions return value. Every Function needs at least one argument, the return value. 

\para
A Function \textbf{Function$<P_1,...,P_n>$} is a subtype of \textbf{Function$<T_1,...,T_m>$} iff n == m, in other words, the length of the arguments are equal, and for an arbitrary \textit{i} between 1 and n - 1  \textbf{$P_i$} is supertype of \textbf{$T_i$}. Futheremore \textbf{$P_n$} needs to be a subtype of \textbf{$T_m$}

\subsection{The type of a function call}
The same as the return value.

\subsection{The Function type in RDF Frog}

\subsection{The Function type in }

\subsection{Generic type}
Only a part of the frog type system, and is not possible to use in OTTR. Lets us set types as variables that needs to be set in the function call. The function needs to define what type the generic type is a subtype of. \textbf{Why not use LUB ?} as previusly mention LUB lets ut set a type that can be the Least Upper Bound meaning that LUB<xsd:integer> is compatible with all of subtypes of xsd:integers. So semanticly speeking will except the same types of terms. However the dicidvantage of using LUB in FROG is that another function that utilieses a function which return LUB<xsd:integer> may only except on of its subtypes, resulting in us having to convert the value, this may also result in more errors compared to generic types. The reason for this is that more of the errors will accure during the runtime compared to generics that will catch more of the errors in the type checing part. \textbf{Why not make it possible to generate functions}: possible to make a ottr template to define the different generic functions, then the user could have used an import with the ottr instance that gave the new function a name and type. Since base functions are written in rdf the genration template would make a RDF base function. However the dicidvantage with this solution is the naming part. 

\section{Type checking}

\section{Validation}
\begin{figure}
    \centering
    \includegraphics[scale=0.4]{validationFlow.jpg}
    \caption{The flow of validating functions}
    \label{fig:LC-explenations}
\end{figure}

OTTR performs validation of the templates and instances before expanding the instances. The validation ensures the creator that the templates and instances are syntax correct, that instances refer to an existing template and that the terms provided as an argument for an instance are compatible with the templates parameter types. Therefore, when utilising a frog function in an instance, OTTR also needs to ensure the creator of the templates and instances that the function's return value is compatible with the type of the given parameter in the template. In conclusion, the end goal of the validation of Frog is to be certain that a function call returns a compatible term. 

\para
Since Frog is a typed language and states the return type, the natural solution would be to check that the function's return type is compatible with the template given parameter type. However, to perform this validation, OTTR needs to validate several other parts of the function and the function call before confirming that the return value is compatible. Firstly, OTTR needs to verify that the function call utilises an exciting function; if the function does not exist, there is no need to proceed, as finding the return type of an unknown function is impossible. Secondly, OTTR needs to validate that the function call has the right amount of arguments and that the arguments are compatible with the function's parameters. Lastly, we can then validate the return value. 

\para
However, stating that the functions return type is a particular type does not necessarily mean that the value returned by the function call is of that type. To guarantee the correctness of the return type, Frog must validate the body of the function. As the function's body is a function call, with possible function calls as arguments, Frog needs to validate the function's body in the same manner as OTTR did with the function call in the instance, with one addition. Frog needs to validate that every parameter used in the function body is declared in the function's definition. Performing validation with an undeclared parameter is unfishable, in addition to causing problems in the execution. 

\para
As function calls can contain arguments which again is a function call regardless if it is in the in function body or the body of the function, OTTR and FROG needs to verify that the return type is compatible with the parameter type of the function's parameter. Nevertheless, if Frog validates every made function, and no errors have accrued, we know that every function we can use will return the correct value. Therefore, we propose that Frog first validates all of the functions, guaranteeing that every function returns a value of the type stated by the function before it validates the function calls in the OTTR templates. 

\para
Validating a Frog function would be preform in several steps. The first natural step is to validate that every function call in the function body uses an existing function and that every used parameter is defined. Furthermore, Frog needs to confirm that every function call in the body has the right amount of arguments and that every argument has the correct type. If an argument is a function call in itself, we assume that the function's return type is correct and check if this return type is compatible with the parameter. We can assume that the function calls return type is correct because the next step is to validate precisely this. 

\section{Evaluation}
\begin{itemize}
    \item Lazy evaluation
    \item Frog is pure 
    \item Ensure no evaluation of unused functions 
    \item When to we reach execution 
    \item \begin{itemize}
        \item 1. a base function on the form of an XPath function since we the external libary need the values (and not the function) to be able to execute. Base functions that are specially made for frog will only execute the parts needed for instance the if-function will only execute the first argument that result in a boolean. If the two next arguments are function calls it will only return the function call in it self.
        \item 2. a function call is used to find the name of the function 
    \end{itemize}
\end{itemize}


\subsection{Evaluation in OTTR}
\begin{itemize}
    \item Lazy evaluation -> make sure of that OTTR does not evalute function calls that are needed to expand the template and only once (memorization)
    \item Only evalute when the function reaches a base template
    \item An instance can branch a argument to several base templates 
    \item OTTR gives a warning when using unused variables however it is still possible
    \item None in to base functions 
    \item 
\end{itemize}


\section{Execution}



