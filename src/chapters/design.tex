
\chapter{Design} %can also be named discussion
OTTR proposes various benefits, such as abstraction and Separation of design and content. However, we suggest that appending a programing language, Frog, that makes it feasible to manipulate terms to OTTR will strengthen several benefits, as previously discussed.  In this chapter, we will discuss how the design of Frog.

\para 
In short, Frog will be a purely typed functional programming language, resulting in Frog only allowing pure functions. The advantage of Frog being pure is that Frog can utilise memorisation on the functions. Section X (Evaluation) discusses why memorisation is an advantage in Frog. In addition to being pure, Frog will additionally be a typed language, resulting in the function explicitly stating the type of its parameters and return type. OTTR requires Frog to be typed as OTTR needs to know the type of a given term to perform validation of templates and instances, which OTTR performs before expanding the instances, implying that Frog must confirm a Functions return type. Section Y (Validation) further elaborates on the necessity of Frog being typed. 

\para
The following prefixes will be utlised in the examples of this chapter:
\lstinputlisting[language=turtle, firstnumber = 1]{examples/design/prefixesDesign.ttl}

\section{Overview}

\subsection{Concepts}
\label{concepts}
The addition of Frog to OTTR will introduce two new possibilities. Firstly, to make a personalised function that manipulated terms, and lastly, use these functions in the template body, named a function call. A function call will execute a function for some arguments, replacing the function call with a term. Therefore, a function call is treated as a term in OTTR and Frog, where the type is the return type of the function the function call executes. In addition, OTTR and Frog will handle a Frog function as a term. However, there is no natural type for a Frog function; as a result, we introduce a new type to the OTTR type system, the Function type. Section \ref{extension_ottr_type} goes in-depth on the new Function type. 

\para
A Frog function is constructed in two parts, the function head and the function body. The function body defines what the function does under execution and consist of only one element, a function call. On the other hand, the function head specifies the function IRI, parameters, return type and the generic arguments. The function IRI is an IRI to identify the function uniquely; in other words, the function name. Furthermore, the function head can consist of parameters. However, it is feasible to make a function containing an empty set of parameters. As Frog is typed, a parameter consists of a variable and a type. The variable represents a constant, which the function body can utilise as an argument or a function if the type of the variable is consistent with a function type. Moreover, the type is the type of the variable, which Frog utilises to perform validation.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{FunctionAndFunctionCall.jpg}
    \caption{The strucure of functions and function calls}
    \label{fig:functionCall_and_function}
\end{figure}

\para
Additionally, the Function head specifies a possibly empty set of generic parameters, consisting of a variable and a type, much like an ordinary parameter. However, in this case, the variable depicts a type, and the type represents a subtype relationship between the variable and the type. A generic variable can be occurring in a or as a parameter type, a return type and a generic argument in the function body. Lastly, the function head specifies the return type, representing the type of the value that the function returns. The return type needs to be compatible with the return type of the function body. 

\para
Furthermore, a function call consists of a function IRI, arguments and generic arguments. The function IRI defines which functions for a set of arguments and generic arguments Frog should execute. An argument can be a constant or parameter variable, which must be compatible with the function's associated parameter. In contrast, a generic argument can either be a generic variable or a type compatible with the function's affiliated generic parameter. Note that both the arguments and generic arguments may be empty. Figure \ref{fig:functionCall_and_function} is a visual representation of a function and a function call structure. 

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.3]{term.png}
      \caption{Term}
      \label{fig:term}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.3]{type.png}
      \caption{Frog types}
      \label{fig:type}
    \end{minipage}
\end{figure}

\para
Compared to OTTR, Frog's terms will be equal since functions and function calls will become valid terms in OTTR; consequently, functions and function calls valid terms in Frog. Figure \ref{fig:term} illustrates what a term is in Frog. On the other hand, types have a difference between OTTR and Frog, namely generic types. Generic types will only be available in Frog. Hence the types in Frog will consist of all the types in OTTR in addition. Figure \ref{fig:type} depicts a Frog type. Note that when we talk about types in this chapter, we talk about Frog types if not specified.

\para
Furthermore, there are two types of functions in Frog, base function and a Frog function. However, a Frog user will only make frog functions but can utilise both base functions and Frog functions the same way in function calls. Base functions will be a combination of XPath[source link] functions, which will operate on some of the base types, and built-in java functions that will work on the complex types, such as the list types. Indifference to a normal Frog function, the function body of a base function will not contain a function call, but a rule which is an IRI reference either the XPath function or the built-in java function. An example of base functions are operators, such as addition and divide.

\subsection{Abstract Model}
This section will present three notions: the definition of a correct function call, how Frog will execute a function call and lastly, the dependency between functions and templates and functions. 

\para
Firstly, we will define what a correct function call is. Frog considers a function call correct if the function calls function name corresponds to an existing function, and the arity of arguments corresponds with the arity of parameters in the corresponding function; the same holds for generic arguments and generic parameters. In addition, the type of an argument needs to be compatible with the type of the affiliated parameter, and a generic argument needs to be a subtype of the corresponding generic parameters type.

\para
Moreover, Frog will execute the function calls using substitution, meaning that the arguments in the function call replace their affiliated parameter in the corresponding function body. Similar to the arguments, the generic arguments will likewise replace their corresponding generic parameter in the function body. Frog will perform the substitution recursively until Frog reaches a state only containing constants and base functions. Figure \ref{fig:substitution_example} illustrates the recursive manner in which Frog substitutes the parameters and generic parameters with the function calls arguments and generic arguments. However, a function call on a Frog function may result in a none terminating recursion, resulting in Frog producing an error message.

\para 
Furthermore, OTTR presents several concepts on dependencies between templates, such as that a template directly depends on a template signature if an instance of the template signature exists in the template body of the template\autocite[484]{SLKF_OTTR_2018}. Frog will expand these concepts with four new dependencies between functions and template and functions.
\begin{enumerate}
    \item Function A directly depends on function B if a function call of B occurs in A's function body. 
    \item Function A depends on function B if function A directly depends on function C that either directly or transitively depends on function B. In short, the transitive closure between functions.
    \item A template directly depends on a function F if the template body contains an instance with an argument that is a function call of F. 
    \item Template T depends on function F if T either directly depends on the T or if T depends on a template that directly depends on F. 
\end{enumerate}

\begin{figure}
    \centering
    \includegraphics[scale=0.45]{substitution.jpg}
    \caption{An example of how Frog will perform the substitution when executing a function call}
    \label{fig:substitution_example}
\end{figure}

\section{Syntax}
Section 3.5 introduced OTTRs two serialisations, wOTTR and sTOTTR. As described by Skjæveland et al., stOTTR is made to be a serialisation of OTTR, which is easy for humans two read and write, in addition to being compact\autocite[4]{SLKK_OTTR_2021}. On the other hand, the wOTTR serialisation offers the benefit of leveraging the existing W3C stack, in addition to tools for developing, publishing and maintaining templates\autocite[481-482]{SLKF_OTTR_2018}. Consequently, we propose that Frog also provides two serialisations.

\para
As a consequence of Frog being a part of OTTR and the benefits that wOTTR offers, we propose Frog likewise have an RDF serialisation. Since wOTTR already benefits from leveraging the existing W3C stack, we need to preserve this benefit when adding Frog. For wOTTR to preserve the property of leveraging the W3C stack, everything wOTTR utilises, in this case, Frog, should a possibility of preserving it.  Additionally, wOTTR is the proposed serialisation of OTTR for publishing temp. Hence it will be reasonable to assume when publishing OTTR templates in wOTTR that the Frog functions utilised by the templates are published among the templates in the same format.  

\para
However, utilising RDF comes with its challenges as RDF requires the RDF Frog serialisation to store the information about the functions in triples; Resulting in much metadata that is not necessarily needed for a human to understand. Writing and reading the metadata may also be tedious, mainly because it requires much repetition when writing several functions. The problem of repetition in RDF is a known one as this is one of the problems that OTTR tries to improve. Hence one solution could be to make a template to build a function. However, we propose a second compact serialisation, such as stOTTR, that is easy to read and write. 

\para
We suggest that there is a significant benefit to making an own human-readable serialisation of Frog compared to using an OTTR template to produce the function in RDF, besides it is nice to have a syntax for Frog that matches stOTTR, namely that the serialisation will make it easier for programmers that do not have knowledge of OTTR or RDF to make and produce functions that the OTTR templates can utilise, which means that the serialisation opens of for more people to make functions. However, this claim is only valid if the syntax is easy to learn. Hence, we need to make a syntax that is relatively easy to learn for an experienced programmer. Another argument for a human-readable serialisation is that it is difficult to provide an OTTR template that shortens the function body due to the function body being a uniquely structured list. However, with a human-readable serialisation, we are also open to shortening the function calls, as figure \ref{fig:hrs_example} shows use compared to figure \ref{fig:rdf_example}. 

\para
Due to RDF being the prefered serialisation for publishing functions and the human-readable syntax most probable being the first choice for writing and reading functions, Frog will, as OTTR, provide a translation between the two serialisations. 

\para
To summarise, Frog will, as OTTR, have two serialisations, one written in RDF and one more compact and easy to read and write. In addition, to the possibility, for Frog to translate between the serialisations.

\subsection{Similarities in the two syntaxes}
Both Frog serialisations will have similarities to their counterparts in OTTR. A Frog function can not directly be written into OTTR templates; however, the function calls can be a part of the template body. Consequently, we propose that Frog will have the same syntax for terms and types. 

\para 
A function call will have a similar syntax in both serialisations. LISP languages such as Scheme have inspired the syntax of the function calls, implying that the function IRI and the arguments are in the same list. The advantage of using a list structure for function calls is that list already is an established data structure in RDF. Although utilising list has its challenges as addressed in section \ref{theListProblem}.

\para 
The following two subsections will present the two different syntaxes in detail. They will both present an example of the function that takes a degree in Fahrenheit and returns the degree converted to Celcius. 

\subsection{RDF Syntax}
\label{RDF_syntax}

\begin{figure}[b]
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/Frog/rdfSyntaxExample.ttl}
    \caption{An example of a Frog function that converts Fahrenheit to Celcius using the RDF turtle syntax}
    \label{fig:rdf_example}
\end{figure}

\para
The RDF serialisation is as OTTR defined by a set of SHACL shapes expressions. Due to Frog and OTTR having the same terms and types, the SHACL shapes used to validate Frog will utilise some OTTRs shapes. 

\para
The syntax is built up of the following parts\footnote{Note that the formal defintion of both the function call and the function in the RDF syntax is found in section \ref{implRDF}}: 

\begin{itemize}
    \item \lstinline{:Function} : For Frog to interpret an IRI as a function, we need to explicitly state that the type of the IRI is a Function. 
    \item \lstinline{:type} defines the type of the function, and is a relation between a function IRI and a blank node representing the type.
    \item \lstinline{:returnType} defines a function's return type and relates the blank node representing the type to a type. 
    \item \lstinline{:parameterTypes} defines the types of the parameters and relates the blank node representing a potentially empty list containing the types to the parameters.
    \item \lstinline{:def} is a relation between the function and a list containing \lstinline{:lambda}, a list of the parameter variables, and the function call, in that specific order. 
    \item \lstinline{:lambda} defines that Frog should interpret the list as the list where the second element is the list of parameter variables and the third element is the function call. Frog requires \lstinline{:lambda} to be the first element in the list. 
    \item \lstinline{:functionCall} defines that Frog should interpret the list as a function call. Need to be placed in the start at the list. 
    \item \lstinline{:varType} defines that Frog should interpret the list as a list of generic arguments. \lstinline{:varType} need to be placed at the start of the list. If the list of generic arguments is present Frog demands the list to be right after the function IRI. 
  
\end{itemize}


\subsubsection{The list problem}
\label{theListProblem}
As mentioned earlier, the RDF syntax and the Human Readable syntax will utilise a list containing the name of the function the function call is using, the generic arguments, and the arguments in a list. The advantage of using function calls as a list is that list already is an established data structure in RDF. In addition, the Turtle syntax offers a compact form of writing lists, as section \ref{listInRDF} and figure \ref{rdfCollection} elaborates. 

\para
However, utilising lists as function calls proposes a problem in the RDF syntax, namely that Frog can interpret an RDF list where the first element is an IRI as either a function call or a list. For instance, the list \lstinline{(fn:plus 2 3)} can have several meanings. Firstly, \lstinline{(fn:plus 2 3)} can refer to the list containing the elements \lstinline{fn:plus}, \lstinline{2} and \lstinline{3}. Lastly, \lstinline{(fn:plus 2 3)} can refer to the function \lstinline{fn:plus}, which adds together \lstinline{2} and \lstinline{3}.

\para
Additionally, we have also chosen to express the generic arguments in a list since utilising lists makes it feasible to write short and compact when utilising Turtle, and that list is ordered. As a result, Frog may interpret a list as a literal list, a function call or a list of generic arguments.

\para
As a solution, we propose that function calls and generic argument lists must contain a key IRI as the first element, such that Frog decodes the list correctly. Therefore, the first element in a function call list will be the IRI \lstinline{:functionCall}, while the first element in the generic argument list, on the other hand, will be \lstinline{:typeVars}. As a result, Frog will decode \lstinline{(fn:plus 2 3)} as a list while Frog on the other side interprets \lstinline{(:functionCall fn:plus 2 3)} as a function call. We argue that this solution is less error-prone than trying to interpret the list from the context. In addition, we argue that using key IRIs will make it easier to produce more concrete and correct validation messages. 

\subsection{Human Readable Syntax}
The Human Readable Syntax of Frog, abbreviated with HRS, is based on known programming languages such as python, java and LISP. As a result of Frog having equal terms and types as its OTTR counterpart, OTTR will also inspire HRS. As shown in figure \ref{fig:term}, parameter variable is also a term, resulting in the syntax of a variable in the HRS being the same as in sTOTTR, namely with an? followed with the name of the varible, for instance ?number.  Figure \ref{fig:frogFunctionHRS} depicts a general Frog function written HSM, as python and java have inspired the function head. On the other hand, LISP inspires the function body or the function call. 

\begin{figure}[h]
    \lstinputlisting[language=frog, firstnumber = 1]{examples/Frog/hrsExample.frog}
    \caption{An example of a Frog function that converts Fahrenheit to Celcius using the Human Readable syntax}
    \label{fig:hrs_example}
\end{figure}

\para
A consequence of Frog inheriting terms from OTTR, which again is built up by a subset of RDF turtle (KILDE 1 side 4), is that some patterns would be natural to use, such as <> to define generic arguments and variables, already is in use. In the case of generic arguments and variables, an IRI can be written with \lstinline{<>}, for instance, \lstinline{<http://ns.frog.ottr.xyz/0.1#functionCall>} is the same as the short form :functionCall. As a result of the pattern \lstinline{<>} already being in use, we have decided to define the set of generic arguments and variables with \lstinline{<<>>} to make it somehow similar to javas way to express the set of generic arguments and variables.

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{frogFunctionHRS.png}
    \caption{A genralisation showing Frogs human readable syntax }
    \label{fig:frogFunctionHRS}
\end{figure}

\para 
The HRS portrays the different concepts in the Frog Functions in the following ways\footnote{Note that the formal defintion of both the function call and the function is found in section \ref{implHRS}}:
\begin{itemize}
    \item The function's name will be an IRI uniquely identifying the function. Similarly to the function name in the RDF syntax and the template name in stOTTR. Before the function name, def is used to define the start of the function. 
    \item The set of the generic variables are defined inside <<>> and separated with ,. To define what type the generic variable is a subtype of, we write subtypeOf between the generic variable and type.
    \item The set of parameters are defined inside () and separated with ,.  The HRS defines the parameter type before the parameter name, similar to Java and OTTR.
    \item The HRS defines the return type after the set of parameters with an -> followed by the type of the return value.
    \item Frogs HRS utilises :: as a distinction between the function head and the function body.
    \item The function body is defined as a function call.
    \item HRS ends every function with a . similar to how templates end with an . in stOTTR.   
\end{itemize}

\para 
A function call in the HRS consist of four parts. Firstly, the optional :functionCall IRI,  similar to the IRI found in the RDF syntax. However, the :functionCall  IRI is mandatory if the function call does not contain any arguments due to Frog needing to distinguish between a list term containing one IRI and a function call. We have, however, decided that the :functionCall is optional otherwise since this will result in a more compact syntax and that we assume that there will be few functions that do not expect any arguments. Secondly, the function call contains the function name, the IRI, of the function it is calling on. Thirdly, the set of generic variables found inside <<>> separated with ,.  The set of generic arguments is also optional, depending on what the function the function call utilises expects. Lastly, the function call contains zero or more arguments.


\section{Extension of the OTTR type system}
\label{extension_ottr_type}
Section X mentions that Frog will introduce two new terms to OTTR, namely functions and function calls. A function call term consists of the function name, generic arguments and arguments as formally illustrated in section X (Overview/concepts). On the other hand, however, a function term will only consist of the function name, resulting in the term being an IRI referring to the function. Firstly be argue why typing is necessary for OTTR and Frog separately, and secondly, we will present how we type the new types.

\para
Frog is, as mentioned, a high-level and typed language. Consequently, Frog will be able to take in and return functions; however, since Frog is typed as well, Frog needs to have the possibility to explicitly state that the parameter type and return type is a function. Thus Frog demands a function type. Furthermore, for validation reasons, which section X further elaborates, Frog must manage to check that the type of the argument is compatible with the type of the parameter type. For Frog to perform these compatible validations, the function calls must also have a type.

\para
The arguments for why the new terms need types are similar in OTTR and Frog. However, OTTR is not a programming language; hence it cannot be a high-level programming language. In addition, OTTR templates do not return anything. However, OTTR should, by definition, manage to receive every term as an argument value since mOTTR defines an argument value as a term. Consequently, functions and function calls must be valid arguments in OTTR. Thus, OTTR should permit parameter variables to depict a function, and these parameters can be typed explicitly, resulting in OTTR requiring a type for the function term. Additionally, the choice for OTTR represents a function term as an IRI, which results in an IRI having the possibility to be interpreted as an IRI or a function. OTTR having its own function type will also help determine how to interpret the IRI and make sure that the term is consistently used and typed. The reason for OTTR to type the function calls are equal to reason in Frog, namely to conduct validation. 

\para
The previous paragraphs voice the demand for a new type depicting the function terms. In contrast, they do not explicitly state how to solve the typing concerning the function calls. However, a function call represents another term, meaning that when evaluating a function call, we end up with another term. Hence, the type of a function call is the type of the term Frog evaluates it to be, resulting in the type of the function call being the return value of the function it is calling on. For instance, the type of the function call (ex:FtoC 39.5) has the type xsd:decimal since xsd:decimal is the return type of the ex:FtoC function; see figure x and y for the function definition. Therefore, we do not need to introduce a new type for the function call term.

\begin{figure}
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/design/highORderFunction.frog}
    \caption{An example of an high-order function in Frog, which in this case takes in a function}
    \label{fig:frog_high_example}
\end{figure}

\begin{figure}
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/design/useOfFunctionInTemplate.ottr}
    \caption{An example of a OTTR template where one of the parameters are a function}
    \label{fig:temlate_parameter_function}
\end{figure}


\para
In contrast to the function call, the function terms require a new species, as discussed above, which both OTTR and Frog needs due to, among other things, them performing validation on the templates and functions. We define the new type as the function type. However, as figure X and Y depicts, both Frog and OTTR will use a variable of type Function as the function name in a function call. Hence, both OTTR and Frog require the Function type to state the types of the parameters and the return type. Furthermore, both OTTR and Frog should validate that the type of a function term is compatible with the parameter's function type. Therefore, we need to establish a compatible relation between function types. 

\para 
Consequently, similar to the List and LUB-type, the Function type will likewise take in type arguments. The argument will first contain the parameter types in the correct order and then the return type. As a consequence of a Frog function always having a return value, every Function type will at least contain one argument.

\subsection{Syntax of the function type}
The list and LUB-type have inspired the syntax for the Function type, both for the RDF and the Human Readable syntax\footnote{The formal definition of the function type, both in the wOTTR syntax and the sTOTTR syntax, can be found in section \ref{parser}}. The wOTTR syntax for a list contains two elements, firstly the IRI rdf:List and secondly the type it holds. For instance, \lstinline{(rdf:List (rdf:List xsd:String))} represent the list containing lists containing strings and \lstinline{(ottr:LUB xsd:integer)} represent the LUB-type for xsd:integer. Likewise, the function type will be built-up by a list, where the first element is the IRI :Function, and the rest of the arguments denotes the type of the parameters and the return type. (:Function xsd:string xsd:integer) is an example of a function type representing a function taking in a function with one parameter of type string and returns a value of type integer. 

\para
On the other hand, sTOTTR depicts the LUB and list type with a keyword, LUB for the LUB-type and List and NEList for the two list types, and the argument inside <>. sTOTTR would express the examples given in the paragraph as \lstinline{List<List<xsd:string>>} for the list containing lists of strings and \lstinline{LUB<xsd:integer>} for the LUB-type of xsd:integer. As mentioned, the List and LUB-type syntax inspire the function type syntax for sTOTTR. Hence, the function type in sTOTTR will be built-up from a keyword, namely Function, continued with <> containing the arguments. However, because the function type may contain more than one argument, we have added that sTOTTR will seperate the arguments with a , .  The example of a function with one parameter of type string and returns a value of type integer will therefore look like \lstinline{Function<xsd:integer, xsd:string>}.

\subsection{Formal definition}
OTTR needs one additional type when introducing Frog, namely \emph{the Function type}. The Function type takes in other types as arguments. In the \textbf{Function<$T_1$,...,$T_n$>},\textbf{ $T_1$,...,$T_{n - 1}$} is the type of the function parameters, and \textbf{$T_n$} is the type of the functions return value. Every Function needs at least one argument, the return value. 

\para
A Function type \textbf{Function$<P_1,...,P_n>$} is compatible with the function type \textbf{Function$<T_1,...,T_m>$} iff n == m, in other words, the length of the parameters are equal, and for an arbitrary \textit{i} between 1 and n - 1  \textbf{$P_i$} is supertype of \textbf{$T_i$}. Futheremore \textbf{$P_n$} needs to be a subtype of \textbf{$T_m$}

\section{Generic type}

\begin{figure}[b]
    \centering
    \includegraphics[scale=0.25]{ottr_numeric_types.png}
    \caption{Shows the numeric types in the OTTR type system. The figure is an excerpt of the figure of the OTTR type system found in the rOTTR spec\cite{OTTR_rOTTR}.}
    \label{fig:ottr_numeric_types}
\end{figure}

As mentioned earlier, Frog will be strongly typed and utilise the OTTR type system. However, this presents one problem as Frog also introduces a new term, namely the function call. Recall that the type of a function call is the type of the function it executes return type. A consequence of Frog being strongly typed and that it is valid to utilise a function call as an argument in another function call is that we must explicitly state the exact return type of the function. Hence, making a function that can return different types is impossible and requires the maker of the function to produce one function for each type that needs that function. 

\para
An excellent example of a function that needs several return types is the function fn:plus, which takes in two arguments and adds them together. As figure \ref{fig:ottr_numeric_types} shows, the OTTR type system has 17 different numeric types. Consequently, we need to produce 17 different plus functions, one for each type. If we add all the numeric functions, divide, times and minus, we have to provide 68 functions only for essential numerical operation. However, making 68 functions will be time-consuming and contain many repetitions. 

\begin{figure}
    %\centering
    \begin{minipage}{.5\textwidth}
      \centering
      \lstinputlisting[language=turtle, firstnumber = 1, basicstyle = \small]{examples/design/templateExp.ottr}
    \end{minipage}
    \begin{minipage}{.5\textwidth}
      \centering
      \lstinputlisting[language=turtle, firstnumber = 1, basicstyle = \small]{examples/design/resultOfTemplateEx.ttl}
    \end{minipage}
    \caption{One the left: an example of how a template generating an fn:plus base function could have looked. One the right: the result of expanding the instance fn:plus(fn:plusInteger, xsd:integ), resulting in a Frog base function in the RDF serilaisation}
    \label{fig:generating_function_example}
\end{figure}

\para
One can approach the problem of making more general functions with several approaches, such as generics and code generation. However, we will first argue why using the already existing type LUB(Least Upper bound) would not work. !TODO!

\para
One approach would have been to \emph{generate} the functions. One idea to generate functions would have been to make templates of a function and expand them into a function in the RDF serialisation. The creator of the functions could then have used an import statement to expand the template such that we end up with a resulting RDF function. In the human-readable syntax the import could, for instance, look like \lstinline{@importFunction fn:plus(fn:plusInteger, xsd:integer)}. Consisting of the key \lstinline{@importFunction}, which tells Frog that it should import a function and the instance that it should expand to get the resulting function in the RDF serialisation. After importing the fn:plusInteger function, the creator of the Frog functions, could then have utilised fn:plusInteger in the other functions. Figure \ref{fig:generating_function_example} shows an example of how such a generating template could have looked and the result after expanding the template in Frog with the import \lstinline{@importFunction fn:plus(fn:plusInteger, xsd:integer)}.The templates that define a function will be known as \emph{generating function templates}.

\para  
Another approach is to make Frog a generic language, such as Java. To use a function with a specific type would then require the user to specify the type in the function call. For a creator to utilise the function fn:plus with the xsd:integer type to add together the integers 4 and 3, the creator must write \lstinline{(fn:plus<<xsd:integer>> 4 3)} where the types inside << and >> would be the generic arguments. Figure \ref{fig:generic_function} depicts a generic variable, which we can utilise as a parameter type and return type in the function head and a generic argument in the function body.  

\begin{figure}
    \centering
    \lstinputlisting[language=frog, firstnumber = 1]{examples/design/genericFrogFunction.frog}
    \caption{An example of a generic function, which takes in a number and adds it with itself three times. As the figure shows, we can utilise the generic arguments as parameter types, return type and generic arguments in the function body. }
    \label{fig:generic_function}
\end{figure}

\para 
Both solutions have one thing in common: we need to have the possibility to restrict the types for the generic of the type of the template. Therefore the type arguments, regardless of whether they are arguments to a template for the generation or are generic arguments directly to the function, need to state which type is valid for them to be. We propose that Frog do this by requiring the creator of either the generating function templates or the generic functions to state what type the type must be a subtype of. For instance, in figure \ref{fig:generating_function_example}, the fn:plus generating function template states that the template variable ?type must be a subtype of owl:real. On the other hand, figure \ref{fig:generic_function} shows how a generic function defines that ?t must be a subtype of owl:real. 

\para 
As presented in section X, Frog will use generics instead of generating functions. The main reason generic functions are a prefered solution compared to generating function templates is that generic functions make it feasible to make user-defined functions in the Frog syntaxes that work on several types. On the other side, generating functions would require the user to make a template. Making it possible to make user-defined generating function templates requires that we validate the generating function templates before OTTR expands them, in addition to validating the Frog functions. As a result of validating the generating function templates and the Frog functions instead of only the Frog functions, Frog may be more error-prone. Another argument for utilising generic functions is that Frog is not dependent on OTTR. 

\para
To conclude, this section has presented the problem of making functions that we wish to work with several types. The generating function templates and generic types were presented as solutions. However, the generating function templates make Frog dependent on  OTTR, and the user needs to write the functions as an OTTR template instead of the Frog syntax, which requires a new form of validation. 

\section{Validation}
OTTR validates the templates and instances before expanding the instances. The validation ensures the creator of the templates and instances that the syntax is correct and, among other things, that the instances refer to an existing template, with the correct arity of arguments and that the arguments are compatible typed with their corresponding parameter. When introducing Frog to OTTR, we open up the opportunity to use function calls as arguments in instances, as illustrated in figure \ref{fig:temlate_parameter_function}; consequently, OTTR needs to validate that the function call is correct and has a compatible type with the corresponding parameter. 

\para
As we discussed in section \ref{extension_ottr_type}, the type of a function call is the corresponding function's return type. However, OTTR only validates that the function calls are correct and has the right type is not enough. For instance, the return type stated in the function head is not necessarily the actual return type, as shown in figure \ref{fig:wrong_function}, where the stated return value is xsd:integer; however, the function call fn:concat is returning a value of type xsd:String. Hence, Frog needs to confirm that the function utilised by the instance is correct and that every function that the function depends on is correct.

\begin{figure}
    \centering
    \lstinputlisting[language=frog, firstnumber = 1]{examples/design/wrongReturnType.frog}
    \caption{An example of a function where the type of the value returned by the function and the return type stated in the function head is not compatible(fn:concat is a base funtion taking in to string and returning the concatinated string).)}
    \label{fig:wrong_function}
\end{figure}

\para
Consequently, we need to define what correctness means in the mean of a function. The correctness of a function consists of parts. Firstly, the function body, which is a function call, needs to be correct and secondly, a valid relation between the function body and function head. We have already defined a correct function call in section X; however, we need to define a valid relation between a function body and function head. We define a function to have a valid relation if the following statements are valid:
\begin{itemize}
    \item The return type of the function call in the function body is compatible with the return type stated in the function head. 
    \item The function head has defined every parameter that occurs in the function body.
    \item The function head has defined every generic parameter occurring in the function body.
\end{itemize} 

\para 
However, the correctness of a function refers to the validity of the function in isolation, but a function primarily depends on another frog function. Hence, we define that a function A is dependently correct if Frog considered  A and every function A depends on is correct. Due to dependently correct, Frog needs to validate function until Frog reaches a base template recursively. However, we deem that every function in a function library, which we define as a set of frog functions, loaded into OTTR will be utilised. Hence we argue that Frog should validate that every function is correct, and as a consequence, Frog will, by definition, likewise validate that every function is dependently correct. A second reason for Frog to validate every function in the function library is that Frog is a high-order programming language. Consequently, any function may be used as a parameter or return value; therefore, Frog needs to know that every possible function is correct. A valid function library is then a function library where every Frog function is dependently correct.

\para
To summerise, Frog needs to validate the following points for each function for the function library to be a valid function library: 
\begin{itemize}
    \item The return type of the function call in the function body is compatible with the return type stated in the function head. 
    \item The function head has defined every parameter that occurs in the function body.
    \item The function head has defined every generic parameter occurring in the function body.
    \item The function calls in the function body must refer to an existing function or an variable of the function type. An existing function is a function that either is a part of the function library or a base function. 
    \item The function calls in the function body need to have the same arity of arguments as the arity of parameters in the affiliated function.
    \item Every argument in the function body must be compatible with its corresponding parameter.\footnote{Frog will also validate that the function is a exisiting function if the corresponding parameter is of the function-type and the argument is not a variabel. } 
    \item The function calls in the function body need to have the same arity of generic arguments as the arity of generic parameters in the affiliated function.
    \item Every generic argument in the function body must be a subtype of the corresponding generic parameter. 
\end{itemize}

\subsection{The three phases of validation}
The previous section has discussed what to validate in a Frog function. In addition to when Frog should validate the function library. However, the section does not discuss in which order Frog should perform the different validations. The goal is for Frog to deliver as many validation errors as conceivable. 

\para
However, some of the validation points depend on one or several of the other validation points. For instance, to validate that the arity of arguments is correct, Frog needs to know that the associated function exists; since Frog compare the arity of arguments to the arity of parameters in the associated function, the same holds for validating the arity of generic arguments. Figure \ref{fig:validationDependencies} defines the dependency relationship between the validations points\footnote{Note that the dependency relationship between validations points is transitive}. 

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{validationDependencies.jpg}
    \caption{The dependencies between the different validations}
    \label{fig:validationDependencies}
\end{figure}

\para
Consequently, we have divided the validation into three phases. Firstly, validate that the function is an existing function or parameter of the function type and that the function head has defined the parameters and generic parameters utilised by the function body. Secondly, the return type defined by the function head matches the return type of the function body, and the arity of arguments and generic arguments in the function body is correct. Lastly, the arguments correspond with the compatible parameter, and the generic arguments are a subtype of the corresponding generic parameter. The flowchart in figure \ref{fig:LC-explenations} illustrates the three phases. 

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{validationFlow.jpg}
    \caption{The phases and flow of validating a function}
    \label{fig:LC-explenations}
\end{figure}

\subsection{Validation warnings}
Messages in OTTR has four different severity degrees: info, warning, error and fatal. The validation points previously discussed would result in messages with the severity degree error. A result of a message with the severity degree error is that OTTR does not expand the graph. However, on the other hand, the severity degree warning will allow OTTR to expand. Frog will utilise the warning messages to state that the functions state something unnecessary, such as a parameter or a generic parameter defined in the function head, which the function body does not utilise.  


\section{Evaluation}
TODO:write introduction

\subsection{Frog functions \& Base functions}
As section \ref{concepts} briefly mentions, functions in Frog can be divided into two, the Frog function, which the user of Frog can make and some built-in base functions. One can consider the base function to be the primitive function of Frog. Base functions are the lowest procedures that Frog can perform and is defined as a function that performs a single task on a set of values, such as multiplying two numbers together, retrieving the first element in a list, and concatenating two strings together. A Frog function will then, in reality, define a way to combine the base functions to perform a specific task. For instance, a function multiplying every number in a list with 5, illustrated by figure \ref{fig:list_multiplication}. 

\begin{figure}
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/design/multiplyNumnber.frog}
    \caption{A function multiplying every number in the list with 5. The result of evaluating the function call \lstinline{(ex:multiplyNumbers (1 2 3))} whould be (5 10 15)}
    \label{fig:list_multiplication}
\end{figure}


\para
Furthermore, we can classify base functions into two groups. Firstly, a set of functions operating on the basic types that utilise XPath functions and operations. Secondly, a set of functions operating on OTTR specific types, such as lists and special functions like the if-function. Frog will base the two groups of base functions on two different technologies, which Section \ref{implementation_evaluation} further elaborates. However, the two groups have one thing in common: they need to know at least one of their working values. What values to elevate is defined in the function\footnote{Some functions may not need to evaluate every value, such as the if function, which only needs to evaluate the boolean value to decide which of the other values it should return. The function fn:plus, on the other hand, needs to know the number value of both of their arguments}. 

\subsection{Argumentation for Lazy evaluation}
When it comes to Frog, the primary purpose of an evaluation strategy is to avoid unnecessary evaluations. Especially regarding base functions, as we assume that computing the base function is the most time-consuming process when evaluating a function call. Therefore we propose that Lazy evaluation is the most suitable evaluation strategy. 

\para
One of the benefits of Lazy evaluation is that it only will evaluate expression or function calls when Frog needs them. Hence we need to define when Frog needs to evaluate an expression. In the previous section, we discussed the correlation between base functions and frog functions and how base functions have defined which arguments need to be evaluated for the base function to execute their task. Therefore, we define that Frog needs to evaluate a function call only when a base function requires it.

\para
We assume that an Eager evaluation approach may have resulted in unnecessary operations compared to the Lazy evaluation, as shown in figure \ref{fig:leVSEe_example_frog}, which illustrates the contrasts in how many evaluations the function call \lstinline{(ex:biggestNumberList 5 6 (ex:multiplyNumbers (1)))} leads to regarding the two different evaluation strategies. The reason for the significant contrasts in eager and lazy evaluation, in this case, is that eager evaluation evaluates the arguments before substituting them into the function. The result of eager evaluation evaluating every argument is that the function call \lstinline{(ex:multiplyNumbers (1))} is evaluated even though never being used. In contrast, Lazy evaluation waits to evaluate the arguments until they are needed, resulting in function call \lstinline{(ex:multiplyNumbers (1))} never being evaluated. Note that in this case, the amount of evaluation needed when using Eager evaluation will increase linearly\footnote{to be precise 4n + 3, where n is the number of elements in the list} when appending elements to the list. In contrast, Lazy evaluation will have a constant amount of evaluations\footnote{to be precise 1}.

\para
An additional benefit of Lazy evaluation is memorisation, which is achievable due to Frog being a pure programming language. Memorisation will ensure that Frog only evaluates an expression once, retrieving the result from a look-up table if Frog previously has evaluated the function call. The function call \lstinline{(fn:plus<<xsd:integer>> (fn:plus<<xsd:integer>> 2 2) (fn:plus<<xsd:integer>> 2 2))} is a simple example of why memorisation in Frog is beneficial. Without memorisation, Frog would have needed to evaluate \lstinline{(fn:plus<<xsd:integer>> 2 2)} twice. In addition to being beneficial for Frog, memorisation will also be valuable for OTTR, as we discuss in the next section. 

\para
To summarise, we propose that Lazy evaluation is the most appropriate evaluation strategy for Frog since Lazy evaluation only evaluates the function calls when required and only once due to memorisation.

\begin{figure}
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/design/biggestNumberList.frog}
    \caption{A function taking in two number and a list, returning the list if the first number is bigger than the second, if not the function returns an empty list}
    \label{fig:biggestNumberList}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.45]{frogEvaluationExample.jpg}
    \caption{Illustrates how the evaluation will look when using Eager evaluation compared to Lazy evaluation on the function call \lstinline{(ex:biggestNumberList 5 6 (ex:multiplyNumbers (1)))}, utilising the functions from figure \ref{fig:biggestNumberList} and \ref{fig:list_multiplication}.  The generic syntax is removed to save place. }
    \label{fig:leVSEe_example_frog}
\end{figure}

\subsection{Evaluation in OTTR}
Evaluation in OTTR refers to when OTTR should execute the function calls in the templates and instances. We suggest two approaches, firstly, an more eager approach, which evaluates the function call as soon as OTTR reaches the instance containing the function call before expanding the instance—in other words, substituting the function call with the evaluation result as soon as possible. Secondly, to evaluate the function call when it reaches a base template, a non-strict evaluation strategy.

\begin{figure}
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/design/evlautionOTTR.ottr}
    \caption{An example of a OTTR template that contains an unused parameter, namely ?name. }
    \label{fig:ottr_evaluation_example}
\end{figure}

\begin{figure}
    \lstinputlisting[language=turtle, firstnumber = 1]{examples/design/evlautionOTTRUsage.ottr}
    \caption{An example instance of the template found in figure \ref{fig:ottr_evaluation_example},  where ex:concatName is the function the first and last name together with space between the names}
    \label{fig:ottr_evaluation_example_usage}
\end{figure}
\para
When producing OTTR templates, OTTR does not require us to utilise every parameter in the template body, even though OTTR throws an error when OTTR finds an unused parameter. Therefore, we can not guarantee that every argument is required for expansion when creating an instance. 
Figure \ref{fig:ottr_evaluation_example} is an example of a template that does not use every parameter. If we were to utilise the eager approach, OTTR might evaluate unnecessarily functions calls, as the template does not require the corresponding parameter to be used. When using an eager strategy, expanding the instance from figure \ref{fig:ottr_evaluation_example_usage} would result in OTTR evaluating the ex:concatName function call even though the evaluation is not necessary for the expansion of the instance. On the other hand, utilising a non-strict evaluation strategy would result in OTTR solely evaluating the function calls when it reaches a base template, hence only evaluating the function call when OTTR needs the evaluated value for the expansion. Expanding the instance from figure \ref{fig:ottr_evaluation_example_usage} would, in contrast to the eager approach, result in OTTR never evaluating the ex: concatName function call when utilising a non-strict evaluation strategy. 

\para 
Furthermore, OTTR discards instances with none as arguments to a mandatory parameter (Prøve å finne en kilde). For illustration, the instance \lstinline{o-rdf:Type(none, (fn:makeIRI "xsd" "integer"))}\footnote{o-rdf:Type is a template found in the OTTR template library http://tpl.ottr.xyz/}, where fn:makeIRI is a Frog function making an IRI from a prefix label and the name part thingi(?). Both of the parameters in o-rdf:Type are mandatory, resulting in OTTR discarding our instance. However, an eager strategy would result in OTTR evaluating the fn:makeIRI function call, despite OTTR never needing the evaluated value. A non-strick approach, on the other hand, would not evaluate the function call since OTTR discards the instance the expansion reaches a base template.

\para 
Nonetheless, utilising a non-strick approach to evaluate the function call may lead to OTTR executing the same function several times. For example, the instance \lstinline{ex:person(ex:Peter "Peter Jensen" (fn:minus 25 1))} from the template found in figure \ref{fig:ottr_evaluation_example} would result in OTTR evaluating the fn:minus function call twice since the template uses the parameter in two base templates. The number of base templates a function call reaches may be numerous in other cases. On the other side, the eager strategy would only evaluate the function call once because OTTR would substitute the function call with the evaluate value before expanding the instance. However, since Frog will use memorisation, utilising a non-strick approach would, OTTR will, in practice, only evaluate the function call once.

\para
In summary, a non-strict approach in OTTR combined with the memorisation in Frog will result in OTTR only evaluating a function call once and solely if OTTR needs the evaluated value for the expansion, hence removing unnecessary evaluations and repetitions. For this reason, we argue that a non-strict approach is a more suitable strategy for OTTR to decide when to evaluate the function calls compared to an eager approach. 

\subsection{Summary}
As discussed, we assume that Frog and OTTR will benefit more from a Lazy evaluation than an Eager evaluation approach. In short, the conclusion is the same for both Frog and OTTR, namely that Lazy evaluation only evaluates a function call once and only if it is needed, removing unnecessary evaluations. We argue that this will result in Frog and OTTR using less time, in general, evaluating the function call compared with Eager evaluation. 
