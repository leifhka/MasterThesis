
\chapter{Implementation}
In this chapter, we will discuss the implementation of Frog. Most of the chapter will discuss how we have implemented Frog in isolation, while the last section, section X, will describe the changes performed in OTTR to integrate Frog. Lutra is the name of the implementation of OTTR and is written in Java\footnote{Lutra is open source and can be found on the following link \url{https://gitlab.com/ottr/lutra/lutra}}. Furthermore, Frog will be an integrated part of Lutra. Consequently, we have also written Frog in Java and utilised some of the same technologies since utilising the same technologies lets us reuse code written for OTTR. As a consequence of Frog utilising Lutras OTTR implementation, section X will briefly introduce the Lutra implementation of OTTR needed to understand the subsequent sections. 

\para
Figure \ref{fig:basic_program_flow} illustrates the basic program flow of Frog as an isolated program. In short, the implementation will start with parsing the function either in the RDF syntax or in the Human readable syntax into a frog function java objects. The parsing of the syntaxes is described in section X. Secondly, Frog will validate the functions in the function library. Validating the function is a three-step process: transforming the function into a special RDF syntax and then performing validation with SPARQL on the first and second validation phase before proceeding to validate the third validating phase with a Java implementation. A furrow discussion on the implementation of the validation step is found in section Y. Lastly, Frog executes the function calls, as discussed in section Z.

\begin{figure}
  \centering
  \includegraphics[scale=0.45]{programFlowDesign.jpg}
  \caption{The basic flow of the Frog in isolation}
  \label{fig:basic_program_flow}
\end{figure}
\para
All three steps depend on the previous step, implying that the validation step requires the parsing to be complete without causing an error message. Additionally, the execution step will only proceed if Frog completes the validation sept without any error messages.  

\section{Overview OTTR implementation}
As mentioned, Lutra is the implementation of OTTR. We will, in this section, discuss Lutras implementation revolving around templates and instances as we consider the implementation regarding tabOTTR and bOTTR irrelevant since Frog functions are to be utilised in the templates and instances. We can utilise Lutra to read and write templates and instances and expand the instances by using a command line interface\footnote{The command line interface for Lutra can be found her \url{https://ottr.xyz/\#Lutra}}. Furthermore, we can, as with Frog, consider the expansion of instances in Lutra to consist of three parts: first parsing, both the wOTTR and stOTTR syntax, secondly to validate the templates and instances and lastly, expanding the templates.

\para
Lutra parsing transforms the templates and instances written in the two serialisations into objects. Hence, classes for terms and types in Lutra already exist, which we can utilise in the Frog implementation due to OTTR and Frog using the same type and term system. We argue that utilising the same classes will make OTTR and Frog more seamless. Furthermore, both the parsing considering wOTTR and stOTTR utilises two different technologies. Firstly, wOTTR uses Jena. Jena or Apache Jena is a framework built for integrating Semantic Web and Linked Data technologies and applications in Java. Including parsing RDF data in different serialisations and executing SPARQL queries\cite{apache_jena}. Secondly, stOTTR uses ANTLR v4\footnote{\url{https://www.antlr.org}}. ANTLR v4 is a library made to describe grammar formally and translate the grammar into parsing code which is both executable and human-readable\cite{antlr4Book}. ANTLR does, in addition, produce error messages if the templates or instances are not compatible with the grammar. The grammar describing templates and instances in the stOTTR serialisation can be found in the sTOTTR documentation\cite{OTTR_stOTTR}.

\para
Lutra performs validation on the objects produced by the parsing by conducting several queries on the objects. Furthermore, Lutra's own defined queries engines describe the queries. However, Frog will not use the queries engines, as we will discuss in section \ref{implValidation}; therefore, we will not go in-depth on the validation part of Lutra. 

\para
TODO: something about expansion. 

\subsection{Result and MessageHandle}
This section briefly introduces the classes MessageHandler and Result, two central classes in the Lutra implementation for handling messages produced to the user. The implementation of Frog applies these two classes, and they are present in several of the examples in this chapter. 

\para
The MessageHandler and Result class rely on messages, which Lutra stores in a Message class. A Message class contains a severity, a message and a possible empty stack trace. The severity of a message can either be info, warning, error and fatal, where info is the lowest degree of severity, and fatal is the height. When Lutra prints a message to the user, Lutra includes the severity degree, as illustrated by figure X.  

\para
Lutra applies MessageHandler as a means to collect messages and handle how to print them to the terminal. Furthermore,  Lutra uses the Result class when calculating values that may result in the calculation failing, hence, producing a message. The Result class works as a wrapper class for Optional\footnote{\url{docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Optional.html}}; as a Result class consists of an Optional value and a trace, which is a possibly empty set of messages produced when working on the result. The Result class implements the methods implemented in the Optional class, such as map and filter. In addition to some Result specific methods often regarding messages, for instance, mapOrElse and addMessage.

\section{FunctionStore}
The FunctionStore is a central class in Lutra's Frog implementation, and Lutra utilises this class in every step of the three-step step of Frog in the implementation. Furthermore, a FunctionStore object is a counterpart to a function library. The FunctionStore offers an interface that, among other things, offers to add functions objects to the store, conduct validation on the functions and execute function calls. The implementation of some of the different methods are shown in their belonging steps section. For instance, Section X, which discusses the implementation, elaborates on the  FuncsionStores validation method. 

\section{Parser}
\label{parser}
As formerly mentioned, the parsing step in Lutra's Frog implementation consists of transforming the function found in an RDF syntax or HRS document into function objects. Lutra has already created the terms and types classes\footnote{Term and Type are interfaces in the implementation; however, we have drawn them as classes} before the introduction of Frog, except the terms and types introduced by Frog, such as functionCall, which we have introduced into Lutra. Figure \ref{fig:FunctionClassDiagram} illustrates the classes involved when creating a function object.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{FunctionClassDiagram.jpg}
  \caption{A UML diagram of a function. Note that this diagram has removed unnecessary connections and is a simplification of the actual code.}
  \label{fig:FunctionClassDiagram}
\end{figure}

\para 
Furthermore, constructing the objects introduced to Lutra when introducing Frog consists of two phases:
\begin{enumerate}
  \item Retrieve the data from the Frog document
  \item Using a builder\footnote{https://projectlombok.org/features/Builder} to create the objects that perform some basic validations, such that values are not null. 
\end{enumerate}
Due to Frog having two serialisations, the first phase has two implementations: one for the RDF syntax and one for the Human readable syntax. Section X and Y discuss the implementation of phase one for RDF syntax and HRS separately. Moreover, the second phase consists of constructing the objects by utilising a builder. Every class has a separate builder, such as a ParameterBuilder that produces parameter objects, which produces the objects and performs basic validation. We argue that performing validation in phase two of the parsing is more beneficial than phase one because phase two has one implementation compared to phase one with two implementations, resulting in less repetitive code. 

\para
The validation performed by the parsing step must not be mistaken with the validation discussed in section \ref{designValidation}. The discussion on the implementation of section \ref{designValidation} can be found in section \ref{implValidation}. Moreover, the validation performed in section \ref{designValidation} needs the context of the function library, such as checking that the function exists. On the other hand, validation performed in the parsing step only needs the object's context. For instance, validating that a function does not contain two parameters with the same variable name. 

\para
Figure \ref{fig:parserFlow} illustrates a general interaction between one of the parsers from phase one and the builder from phase two. In addition to showing the relationship between a builder and the subsequent class. As we see from the figure, the builder checks that every mandatory argument needed to create the class is present before creating the object. Thereafter, if present, the builder calls the validate method on the object. 

\begin{figure}
  \centering
  \includegraphics[scale=0.6]{parserFlow.jpg}
  \caption{A sequent diagram showing the general interaction between a parser, builder and class. }
  \label{fig:parserFlow}
\end{figure}

\subsection{RDF Syntex}
\label{implRDF}

\subsection{Human Readable Syntax}
\label{implHRS}
\subsubsection{Technologie}
We will utilise ANTLR v4 to define the grammar of Frog functions and function calls, precisely as with OTTR.  Due to the Human Readable-Syntax(HRS) of Frog inheriting the syntax of terms and stOTTR applying ANTLR v4 lets us reuse some of the grammar specifications and the code from the stOTTR part of the Lutra implementation. 

\subsubsection{Grammar}
One advantage of Frog utilising the same terms and types as OTTR is using the declared ANTLR v4 grammar from stOTTR. In ANTLR, we can reuse previously defined grammar by importing them. Hence, the start of the Frog grammar file will consist of specifying the name of the grammar for this file, namely Frog, and that we should import the parsing rules from stOTTR. 

\para
\lstinputlisting[language=antlr, firstline = 1, lastline = 3]{examples/implementation/Frog.g4}


\para
However, before we continue to depict the Frog grammar, we will define the changes to the stOTTR that the inclusion of Frog has provoked. As previously discussed, Frog introduces one new type, namely the Function type. In stOTTR, the grammar defines the function type by the keyword Function continued with arguments representing the parameter types and return type.

\para
\lstinputlisting[language=antlr, firstline = 110, lastline = 120]{examples/implementation/stOTTR.g4}

\para
Furthermore, Frog introduces two new terms to OTTR: the function term and the function call. However, the syntax for a function term is equivalent to an IRI term; consequently, the function term does not change grammar since the distinction between an IRI term and a function term is semantic. On the other side, the function call introduces a new term in OTTR, which we need to define in the stOTTR grammar. A function call is built-up as a list surrounded by round brackets \backgroundText{( )} and space separating the elements. Furthermore, a function call consists of an optional function call definition, the function name, the generic terms, and an arbitrary number of terms. The generic arguments are surrounded by two angle brackets on each side \backgroundText{<< >>} and an arbitrary number of generic variables, such as a variable or a type.

\para
\lstinputlisting[language=antlr, firstline = 141, lastline = 165]{examples/implementation/stOTTR.g4}


\para
The Frog grammar can continue now that the stOTTR grammar has defined the new terms and types. A document containing HRS function definition can, as stOTTR, include an arbitrary number of RDF prefixes and base declaration, as defined by the Turtle(KILDE) serialisation of RDF, which the grammar formally names directives. In addition to directives, the HRS Frog document can also contain any number of functions.  

\para
\lstinputlisting[language=antlr, firstline = 5, lastline = 8]{examples/implementation/Frog.g4}

\para
A Frog function consists of a function head and a function body. The function body is, as earlier mentioned, a function call; consequently, the function body uses the parsing rule for the function call defined in the stOTTR grammar. On the contrary, the function head needs to define the parsing rules in the Frog grammar and consists of a definition, generic parameters, parameters and a return type. The definition consists of the token \backgroundText{def} and the name of the function. Furthermore, the generic parameters are defined as a variable, the token subtype and a type, and are separated with a comma and surrounded with angular brackets on each side, \backgroundText{<< >>}. Moreover, the Frog HRS grammar depicts parameters as a type followed by a variable and are separated with a comma and surrounded with round brackets on each side \backgroundText{( )}. Lastly, the return type consists of the token \backgroundText{->} and a type. The function head and function body are divided by the token \backgroundText{::}.

\para
\lstinputlisting[language=antlr, firstline = 10, lastline = 48]{examples/implementation/Frog.g4}

\para
Lastly, the Frog grammar needs to redefine what a type is by including the generic type in addition to redefining the LUB-type, such that the LUB-type can accept a generic type as an argument and not only a basic type. In ANTLR v4, we can override parsers rules from the imported grammar. ANTLR will always utilise the parser rule defined by the rules defined in the Frog rather than the rule defined in the stOTTR grammar.

\para
\lstinputlisting[language=antlr, firstline = 51, lastline = 66]{examples/implementation/Frog.g4}

\para 
Admittedly, we could have defined a new parsing rule named frogType which could either be a type or a genericVariable. However, by overwriting the type parsing rule type in the Frog grammar, we avoid defining the list and function type again in the Frog grammar.

\subsubsection{From grammer to objects}
As mentioned, ANTLR4 generates classes and objects based on the defined Frog grammar, which Lutra utilises to parse the function document into function objects. ANTLR turns the document provided into a parse-tree and offers two different techniques for traversing the parsing three, namely parse-tree listeners and parse-tree visitors. Figure \ref{fig:parse_tree_example} is an example of a parsing three produced by ANTLR. Lutra's OTTR implementation utilises the visitor method for traversing the parsing tree. When expanding Lutra with the addition of Frog, it is beneficial to apply the same method since we can reuse the code written for Lutra's stOTTR parsing in the parsing of the HRS of Frog. 

\para
ANTLR's visitor technique lets us control the traversing by explicitly calling methods to visit children(KILDE antlr book). From Figure \ref{fig:parse_tree_example}, the functionHead's children are definition, genericParameter, parameters and returnType. ANTRL generates a base visitor class with an interface containing one visit method for each parsing rule in the grammar to perform the traversing. In the Frog grammar case, ANTLR generates a class FrogBaseVisitor that offers methods like visitParameter and visitFunction. However, the base visitor implementation of the visit methods only contains one action, to visit the children. Hence, we have made parser classes in Lutra that expand the FrogBaseVisitor and override the methods to define the method and create an object of the belonging class. For instance, code \ref{parameterParser} shows the class FParameterVisitor containing the method visitParameter since a parameter consists of a type and a variable. A parameter has two children a variable: a variable, which is a term, and a type. Hence the visitParameter needs to use the term and type parser to parse the children.

\begin{figure}
  \begin{code}
      \label{parameterParser}
      An example of a parser class, this parser class i the parser for a parameter. The FBaseParserVisitor class extends the FrogBaseVisitor, wrapping the generic argument into a result class (class FBaseParserVisitor<T> extends FrogBaseVisitor<Result< T > >).  
  \end{code}
  \lstinputlisting[language=Java, firstnumber = 1, basicstyle=\small]{examples/implementation/FParameterParser.java}
\end{figure}

\para
Notably, Lutra already contains several parsing classes and visitor methods due to the stOTTR implementation, such as visitList and visitListType. Consequently, the addition of Frog resulted in expanding some of the parsing classes made for stOTTR, such as introducing a visitFunctionType method to the type parser class, in addition to introducing parsing classes for the Frog function-specific objects, such as function and generic parameters. 


\begin{figure}
  \centering
  \includegraphics[scale=0.23]{antlr4_parse_tree_example.png}
  \caption{The generated parser-tree made by ANTLR4s java implementation on the function in figure \ref{fig:generic_function}}
  \label{fig:parse_tree_example}
\end{figure}

\section{Validation}
\label{implValidation}
This section presents the implementation of the validation elaborated on in Section X. Note that Lutra only performs the validation on the frog function if Lutra completes the parsing stem without producing messages with severity degree Error or higher. Furthermore, as figure Y illustrates, Lutra executes the validation in three phases, and a phase is only executed if the previous phases are performed without any validations errors. Note that we have moved the implementation of step 6, which checks that the function has the correct return type. In short, we had to move step 6 in the implementation due to limitations in the desired technology, namely SPARQL. Section X discusses why this move is inevitable.

\subsection{Technology}
As mentioned, Lutra utilises a custom created queries engine built-in Java made to perform validation on OTTR templates and instances. Hence, when working with validation and OTTR, one must learn this custom created query engine. However, we argue that using established technologies compared to Lutra's custom created queries is more beneficial for several reasons. 

\para
Before stating the benefits, we need to specify what established technology we argue for, namely SPARQL, and why we propose that SPARQL is an established technology. Section X introduces SPARQL and describes that SPARQL is a query language over linked data structured by RDF. Furthermore, SPARQL is the standard language to perform queries and extract data from RDF documents, as stated by Mosser et al.\cite[1]{MosserSPARQL} and Peréz er al\cite[1]{PerezSPARQL}. Additionally, the W3C has endorsed SPARQL as a W3C document. Hence, we argue that SPARQL is an established semantic technology. 

\para
Furthermore, we assume that the users of OTTR are knowledgeable regarding the well-establish semantic technology; due to OTTR being a language offering tools to represent semantic technologies, such as RDF and OWL, through modelling patterns[KILDE: OTTR]. Consequently, we consider SPARQL to be a known technology for OTTR users. 

\para
Now that we have introduced SPARQL as an established semantic technology and known to OTTR users. We will proceed with arguing why we believe that conducting validation through SPARQL queries is beneficial. Firstly, applying SPARQL queries results in Frog validation leveraging the existing W3C. In addition, the SPARQL validation queries formally describe and specify Frog's validation. Similarly to how SHACL shapes define the OTTR wOTTR serialisation and the Frog RDF serialisation. Secondly, the users of OTTR can understand the validation straight from the validation queries due to SPARQL being a comprehended technology. Lastly, we argue the Frog benefits for that the validation using SPARQL queries are relatively easy to maintain due to SPARQL being a well-established and documented technology. Furthermore, we do not need to know about Lutra's implementation to change and update the queries because the SPARQL files are separate from the implementation. Consequently, updating the validations later will only require the programmer to know about SPARQL queries and the special RDF serialisation in isolation.

\para
However, performing all the validation in SPARQL has proven impracticable due to the incapacity to conduct recursive queries with SPARQL language\cite[711]{RecursionSPARQL}. We argue that recursive queries are beneficial when validating that one type is compatible with another type due to the recursive manner in which OTTR and Frog define the function type and list type and the recursive definition of compatibility on these types. Consequently, all the validation regarding compatible typing and subtyping, namely validating right return type, argument types and generic argument types, needs to be validated in a recursive manner. Reuter et al. discuss recursion in SPARQL and propose a recursive linear operator, which they implemented as an extension of the Jena\cite[732]{RecursionSPARQL}. Nevertheless, implementing this extension on top of Jena in Lutra is out of scope for this thises. An effort to perform the validation mentioned above with SPARQL through property paths and a complex representation of types in the RDF syntax. However, attempting to make these queries was not sufficient. 

\para
Consequently, Lutra is limited to utilising java implementation for the validation depending on types. We then made three simple recursive methods in the validation function. As illustrated by figure X, we considered these methods moderately uncomplicated. Hence, we have leveraged SPARQL and Jena's SPARQL implementation as far as technically possible and use relatively simple java methods where applying SPARQL is proven to be complicated. We argue that the benefits mentioned regarding SPARQL, such as getting a formal definition of the validations being easy to maintain and understand for a user of OTTR, are more substantial compared to Lutra's query engine. Although we only leverage in parts of the validations. 

\subsection{Validation Flow}

\subsection{SPARQL}
This section discusses the validation implementation that applies SPARQL as their technology. Firstly, we introduce the special RDF syntax utilised to perform the SPARQL queries. Secondly, we discuss the SPARQL validation queries, focusing on the queries regarding validating the following: function name exists, undefined parameter, and the right amount of arguments. Lastly, we examine the Lutra implementation for executing the SPARQL validation queries. 

\subsubsection{Special RDF syntax for validation}
\begin{figure}
  \begin{minipage}{.4\textwidth}
    \lstinputlisting[language=turtle, firstnumber = 1, basicstyle = \small]{examples/implementation/specialSyntaxParameter.ttl}
    \caption{Illustrates how a parameter looks in the special RDF syntax}
    \label{fig:specialRDF_parameter}
  \end{minipage}%
  \begin{minipage}{.5\textwidth}
    \centering
    \lstinputlisting[language=turtle, firstnumber = 1, basicstyle = \small]{examples/implementation/sepcialSyntaxFunctionCall.ttl}
    \caption{Illustrates how a function call, arguments and generic arguments looks in the speciial RDF syntax}
    \label{fig:specialRDF_functionCall}
  \end{minipage}
\end{figure}
\begin{figure}
  
\end{figure}
To execute the validation, we have made a special RDF syntax for representing the Frog Function. We have based the special RDF syntax on Frog's RDF syntax. Section X discusses why we need a special RDF syntax when executing SPARQL queries instead of Frog's existing RDF syntax. 

\para
There are two main differences between the special RDF syntax and Frog's RDF syntax. Firstly, the use of lists to represent data. The special RDF syntax compared to the Frog's RDF syntax does not utilise to the same degree. Most of the elements represented by a list in Frog's RDF syntax, such as function calls and parameters, have been replaced with a blank node structure in the special RDF syntax to utilise the property paths for easy recursions. Consequently, the special RDF syntax contains more metadata than Frog's RDF syntax. Secondly, the special RDF syntax more closely resembles the structure of Frog functions shown in \ref{fig:functionCall_and_function}, having a more precise separation of the function head and body. Examples of such a change are that a parameter variable and a variable type, in addition to the generic variable and the subtype of, now are connected through the same blank node, as figure \ref{fig:specialRDF_parameter} illustrates\footnote{Note that there is a triple in the parameter regarding the index, which is not used for now. However, we added the index for parameter and several other features with the hopes of not having to change the special syntax if the validation regarding checking the correct arguments are added in the future, as discussed in section Y.}.

\begin{figure}
  \centering
  \begin{minipage}{.5\textwidth}
    \centering
    \lstinputlisting[language=turtle, firstnumber = 1, basicstyle = \tiny]{examples/implementation/functionTypeSpecialRDFSyntax.ttl}
  \end{minipage}%
  \begin{minipage}{.5\textwidth}
    \centering
    \includegraphics[scale=0.5]{functionRDFSpecialExample.jpg}
  \end{minipage}
  \label{fig:specialRDFSyntax example}
  \caption[Function type in the special RDF synta]{The function type \lstinline{Function<xsd:int, Function<xsd:int,xsd:int, xsd:int>, List<xsd:int>>} written in the special RDF syntax on the left, and on the right this function type represented by a tree structre with the depth. }
\end{figure}

\para
As mentioned, the special RDF syntax represents a function call with a blank node, which uses the :of predicate to link the blank node to the function name, the :arg predicate to a blank node representing an argument, the :typeArg predicate to a blank node representing a generic argument. An argument blank node consists of an index, value and a type. However, if the value is a function call, the type is not stated by the argument. Furthermore, the generic argument blank nodes relate to an index and type or a generic variable. Figure \ref{fig:specialRDF_functionCall} is a generalised example of a function call. 

\para
Finally, we will address the complex types, which as the function calls are represented with a blank node structure. The special RDF syntax built up the complex type by stating what complex type it is, a function type, a list type or a LUB type, the type arguments, and the type's depth. Furthermore, the type argument type contains the type and the types' depth. We built up the depth recursively:
\begin{itemize}
  \item Outmost type: the string 0
  \item List or LUB types, n + 1 element : n's string +  the string 0
  \item Function type and parameter, n + 1 element : n's string + parameters index 
  \item Function type and parameter, n + 1 element : n's string + r
\end{itemize}
Figure \ref{fig:specialRDF_parameter} illustrates with a tree structure how we calculate the depth for the function type \lstinline{Function<xsd:int, Function<xsd:int,xsd:int, xsd:int>, List<xsd:int>>} and how this function type looks in the RDF syntax. Additionally, example X shows how the special RDF syntax writes the function from figure Y. 


\subsubsection{Queries}
The purpose of SPARQL validations queries is to find mistakes in the functions, such as the function body utilising a parameter variable that the function has not defined. Additionally, we have made one query for each validation in phases one and two in addition to the two warning validations, all described in section X. However, as the queries find mistakes in the function, the wording of the queries assignment is slightly different than presented in section X, as we have negated them. Consequently, the SPARQL query for validating that a function call in the function body has the correct arity of arguments are worded as finding every function call that does not have the correct arity of arguments. 

\para
In short, we categorise the validation queries into two types, the objective queries and the arity queries. The arity validation, correct arity of arguments and correct arity of generic arguments, are arity queries, and the rest are objective queries. Moreover, the objective queries consist of two stages: Firstly, to find the objective we are validating on, and secondly, to remove the objectives with a correct definition or use, which mainly consist of NOT EXIST clauses. On the other hand, the arity validation queries consist of four stages. Firstly, find all function calls in function bodies. Secondly, find the arity of arguments in these function calls. Thirdly, find the arity of parameters or generic parameters in the functions, in other words, the number of expected arguments or generic arguments. Lastly, utilising a FILTER clause to remove the matches where the function call arity of arguments or generic arguments equals the affiliated function's expected arity.

\begin{query}
    The validation query used to extract the function calls that does not use an exisiting function (either from the function library or a base function) or a parameter of the function type. 
    \label{query:functionExists}
\end{query}
\lstinputlisting[language=sparql, firstnumber = 1]{examples/implementation/queries/checkFunctionExits.rq}

\para 
As mentioned, we will look deeper into three queries. Firstly, as displayed in query \ref{query:functionExists}, the query extracting every function call that does not use a valid function name, we will refer to this query as the existing function query. The existing function query is an objective query. Consequently, the existing function query consists of two stages. Firstly, to find the objective we are validating on, in this case, the function calls in the function bodies. As mentioned, the predicate \lstinline{:of} links a function call to the function name, consequently we want to find every object in a triple with :of as predicate. Consequently, used the triple \lstinline{[] :of ?functionCallName} to extract every function call name. However, we want to produce error messages that include the function name of the function containing the function call. Consequently, as shown on lines 5-6 in query \ref{query:functionExists}, the query extracts the function name and applies property paths to recursively find every function call name in the function's body. Secondly, the objective queries remove every correct use of objective. In the case of the existing function query, the correct use of the function call name is either if the function name is a parameter of the Function type or if the function call name is the IRI of a base function or a function in the function library. Therefore, the existing function query consists of two NOT EXIST clauses. The first clause on lines 10-13 removes matches where the function name is an IRI and is defined as a frog:Function. Furthermore, the second clause on lines 16-21 removes matches where the function contains a parameter that is the function call and as the frog:parameterType frog:Function. 

\begin{query}
    The validation query to find every parameter variable used in the function body that is not defined by the affiliated function head 
    \label{query:undefinedParameter}
\end{query}
\lstinputlisting[language=sparql, firstnumber = 1]{examples/implementation/queries/checkUndefinedParameters.rq}

\para 
Secondly, we will introduce the query to extract every parameter used in the function body that is not defined in the function head, shown in query \ref{query:undefinedParameter}. In short, the undefined parameter query. The undefined parameter query is an objective query similar to the existing function query. However, in contrast to the existing function query, the objective is every parameter variable used in the function body in the first stage. We can use a parameter variable in two places in the function body: as an argument or as a function name. Consequently, as seen on lines 5-11, we utilise a UNION clause to extract them separately. The first part of the UNION clause utilises a property path to find every argument in the function body. Due to that, we can use parameters as an element in a list, such as (2 3 4 ?number), (rdf:rest*/rdf:first)* has been added to the end of this property path to extract every element in a possible list argument. The second part of the union extracts every function call name in the same fashion as the first step in the existing function query. Finally, in the first step, due to that, blank nodes represent parameter variables, we remove the arguments that are not blank nodes, with the FILTER clause seen on line 13. However, the UNION clause extracts blank nodes that are not variable, such as list inside lists, ((1 3 4) (5 9 1)), and function call blank nodes. Consequently, we have added two NOT EXIST clauses on lines 20-27 to remove these specific blank nodes. Furthermore, the second step in an objective query is to remove the correct use. In this case, the correct use is a parameter defined by the function head. Thus we remove every match in which the function defines the parameter variable, as seen on lines 14-16. 


\begin{query}
    The validation query to find every parameter variable used in the function body that is not defined by the affiliated function head 
    \label{query:argumentArity}
\end{query}
\lstinputlisting[language=sparql, firstnumber = 1]{examples/implementation/queries/argumentArity.rq}

\para 
Lastly, we elaborate on the query extracting every function call having a different arity of arguments than the affiliated functions arity of parameters. In short, argument arity query and query \ref{query:argumentArity} depicts this query. As suggested by the name of this query, the argument arity query is an arity validation query. Thus the argument arity query consists of four stages: First, finding all the function calls in the function body. This first step is performed similarly to the first step in the existing function query. However, as seen on lines 3-6, we need the function call and the function call name in contrast to the existing function query. Consequently, we have moved the last part of the property path in the existing function query to line 6 so that we have references to both the function call and the function call name. Secondly, the query needs to find the arity of arguments in the function calls. The argument arity query extracts every argument from a function call and applies aggregation by grouping them after the function call and counting the received arguments by a sub-query, as seen on lines 8-17. Thirdly, the query finds how many arguments each function expects. Due to that, a function call name can be a parameter variable or an IRI referring to a base function or a function in the function library, we have separated this step with a UNION-clause containing two sub-queries, shown in lines 19-49. The first part of the UNION clause counts every parameter of a parameter of type function and groups them after their function call name, which is the parameter variable. Figure X(5.7) illustrates that the frog:argType is used on both the parameter types and the return type of function type; however, the parameters contains a triple stating their index in contrast to the return type. Consequently, as seen on line 31, the query only counts the type arguments that have an index. The second part of the UNION clause is similar to the first part; however, instead of extracting the type arguments of a function type, it extracts the parameters of a function. Lastly, this query removes every match where the received value is the same as expected, as seen on line 50. In query \ref{query:argumentArity}, we utilise optional in the sub-queries counting the parameters and arguments; we need to count the function calls with no arguments and the functions that expect zero arguments. Optional in combination with the aggregation and count will count zero when no parameters or arguments are present in the function

\para 
The queries not elaborated on in this section follow one of the two queries types; thus, the structure of these queries are recognisable. Additionally, two pairs of validation queries are revers objective queries: parameter variable and unused parameter variable, and undefined generic variable and unused generic variable. For a pair of queries to be revers queries two, they must fulfil two demands; we will use X and Y to represent the queries in the pair of revers objective queries: 
\begin{enumerate}
  \item The first stage in X must contain the same query patterns as Y's second stage. Consequently, X's first stage pattern is equal to the pattern found in Y's NOT EXIST clause. If X first stage pattern contains UNION clauses, then each UNION pattern matches the pattern found in a NOT EXIST clause in the second stage of Y.
  \item The second stage in X must contain the same query patterns as Y's second stage. The translation between stage one and stage two is equivalent to point one. 
\end{enumerate}

\subsubsection{Lutra's execution}
Lutra's implementation and execution of the queries consist of two parts. Firstly, a Jena model will construct the functions in the function library and base function in the special RDF syntax into an RDF graph. Secondly, using the Jena query library to read in the query files and execute the queries.  

\para
We have implemented a method for each class that a function can utilise, namely term classes, type classes, the GenericParameter class and the Parmeter class, which either add their special RDF syntax representation to the model or return a resource representing the object. Consequently, the functions recursively build up the model by calling on these methods. 

\begin{code}
  \label{queryClassExample}
  The code of the query class that executes and prodcues messages for query \ref{query:undefinedParameter}. The parameter resulSet contains the result from executing the query, one row for each match.
\end{code}
\lstinputlisting[language=Java, firstnumber = 1, basicstyle=\small]{examples/implementation/CheckUndefinedParameters.java}

\para
As mentioned, we have applied Jena's query library to read in the query files and execute the queries over the Jena model, representing the RDF graph containing functions in the special RDF syntax. Furthermore, we have constructed one class for each query that we will refer to as a query class. The query classes implement the interface FunctionCheck. The interface FunctionChech extends a java Function(link), taking in a Model and returning a MessageHandler. Consequently, the FunctionCheck interface consists of an apply method taking in a model and returning a MessageHandler. Additionally, the interface consists of two other methods that the query classes need to implement: the getValidationFile method, which return the filename of the belonging query file, and the method ErrorMessage method, which produces a MessageHandler containing the possible validation messages. The interface has implemented a default apply method that reads in the query file and calls on the errorMessage method to produce the MessageHandler in which it returns. In code \ref{queryClassExample}, we see an example of a query class, namely the query class CheckVariableExists, which executes query \ref{query:undefinedParameter}. The errorMessage method extracts the values from the result of the queries to produce error messages. In the case of figure \ref{fig:validation_erro_example}, the CheckVairable exist class found in  code \ref{queryClassExample} would produce the following error messages:  

\begin{lstlisting}[language=lutraMessages]
  [ERROR] Variable ?numbr1 which is used in function ex:minus2 is never declared 
  [ERROR] Variable ?number which is used in function ex:minus2 is never declared 
\end{lstlisting}

\begin{figure}[h]
  \lstinputlisting[language=frog, firstnumber = 1]{examples/implementation/validationError.frog}
  \caption{An example of a function that utilises undefined parameters in the function body}
  \label{fig:validation_erro_example}
\end{figure}

 

\subsection{Java}

\section{Evaluation}
\label{implementation_evaluation}

\subsection{Memorisation}
\textbf{NB: tatt fra design delen men ble overflødig og handlet plutselig mer om implementasjonen. Deler kan brukes til dette kampittelet. Figurene er oppdatert}
\\
When determining whether to use memorisation or not, we have to consider the advantages and disadvantages of utilising memorisation in the context of Frog. On the one hand, memorisation will assumably reduce Frog's time to evaluate the function calls. On the other hand, utilising memorisation in Frog will increase the amount of storage needed. In addition, performing a lookup in the lookup table takes in worst-case O(n)(KILDE) when utilising a hash table. Hence, the lookup time should be less than the time used to evaluate the function call. Consequently, we present two criteria we belives needs to fulfil for memorisation in the context of Frog to be beneficial:
\begin{enumerate}
    \item The assumed time used to perform a lookup should be assumed to be less than the time used to perform the function call.
    \item The assumed storage space needed for memorisation in Frog should be considered not to be remarkably high. 
\end{enumerate}

\para 
Before discussing if Frog should use memorisation, we will introduce two new concepts: function call signature and function call description. 
Firstly, a function call signature is the function name combined with the arguments. Note that the generic arguments are not a part of a function call signature. Hence the function call (fn:plus<<xsd:decimal>> 5 6) and (fn:plus<<xsd:integer>> 5 6) will have a equal function call signature. Secondly, in contrast to the function call signature, the function call description contains the generic arguments, the function name and arguments. Thus the function call (fn:plus<<xsd:decimal>> 5 6) and (fn:plus<<xsd:integer>> 5 6) will not have the same function call description.

\para
To further discuss if memorisation satisfies the two criteria, we must present a possible solution to accomplish memorisation in Frog. Two function calls the same function call signature will evaluate the same value since Frog performs the same calculations on the same arguments. However, function calls with different function call definitions may not have the same type on the evaluated value due to the use of generics. For instance, the function ex:plus2 from figure X will have a different return type which Frog must determine from the generic argument ?t. Hence, the function call (plus2<<xsd:decimal>> 5)  would evaluate to \lstinline{15^^xsd:decimal} while (plus2<<xsd:integer>> 5) would evaluate to \lstinline{15^^xsd:integer}. As illustrated, the evaluated value of two function call with an equal function call signature will be equal. However, the function call description may change the return value type.

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{simpleHash.jpg}
      \caption{A generalisation of the lookup table when only considering the function call signature}
      \label{fig:simpleHash}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{lookUpGeneral.jpg}
      \caption{A generlaisation of the lookup table consdiering the function call signature and definition}
      \label{fig:lookUpGeneral}
    \end{minipage}
\end{figure}

\para
Thus, a table consisting of the function call signature and the result value will not be enough as it may result in Frog evaluating the value of a not approved type. Evaluating the function call (plus2<<xsd:decimal>> 5) would result in the lookup table shown in figure X. When trying to evaluate (plus2<<xsd:integer>> 5) afterwards Frog will utilise the lookup table since the function call signature is present; however this will result in Frog evaluating the function call to be \lstinline{15^^xsd:decimal}, which is not a valid value. Therefore, we present a solution in which Frog first checks if the function call signature is present and afterwards checks if the function call definition is present. Figure Y illustrates the general structure, while figure Z shows an instance containing the examples mentioned. 

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{lookUpAfterFirst.jpg}
      \caption{Example lookup table only considering the function call signature}
      \label{fig:lookUpAfterFirst}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{exampelFulllookuptable.jpg}
      \caption{Example lookup table considering the function call signature and defintion}
      \label{fig:exampelFulllookuptable}
    \end{minipage}
\end{figure}

\section{Executor}

\section{Changes in OTTR}

