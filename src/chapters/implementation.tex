
\chapter{Implementation}
In this chapter, we will discuss the implementation of Frog. Most of the chapter will discuss how we have implemented Frog in isolation, while the last section, section X, will describe the changes performed in OTTR to integrate Frog. Lutra is the name of the implementation of OTTR and is written in Java\footnote{Lutra is open source and can be found on the following link \url{https://gitlab.com/ottr/lutra/lutra}}. Furthermore, Frog will be an integrated part of Lutra. Consequently, we have also written Frog in Java and utilised some of the same technologies since utilising the same technologies lets us reuse code written for OTTR. As a consequence of Frog utilising Lutras OTTR implementation, section X will briefly introduce the Lutra implementation of OTTR needed to understand the subsequent sections. 

\para
Figure \ref{fig:basic_program_flow} illustrates the basic program flow of Frog as an isolated program. In short, the implementation will start with parsing the function either in the RDF syntax or in the Human readable syntax into a frog function java objects. The parsing of the syntaxes is described in section X. Secondly, Frog will validate the functions in the function library. Validating the function is a three-step process: transforming the function into a special RDF syntax and then performing validation with SPARQL on the first and second validation phase before proceeding to validate the third validating phase with a Java implementation. A furrow discussion on the implementation of the validation step is found in section Y. Lastly, Frog executes the function calls, as discussed in section Z.

\begin{figure}
  \centering
  \includegraphics[scale=0.45]{programFlowDesign.jpg}
  \caption{The basic flow of the Frog in isolation}
  \label{fig:basic_program_flow}
\end{figure}
\para
All three steps depend on the previous step, implying that the validation step requires the parsing to be complete without causing an error message. Additionally, the execution step will only proceed if Frog completes the validation sept without any error messages.  

\section{Overview OTTR implementation}
As mentioned, Lutra is the implementation of OTTR. We will, in this section, discuss Lutras implementation revolving around templates and instances as we consider the implementation regarding tabOTTR and bOTTR irrelevant since Frog functions are to be utilised in the templates and instances. We can utilise Lutra to read and write templates and instances and expand the instances by using a command line interface\footnote{The command line interface for Lutra can be found her \url{https://ottr.xyz/\#Lutra}}. Furthermore, we can, as with Frog, consider the expansion of instances in Lutra to consist of three parts: first parsing, both the wOTTR and stOTTR syntax, secondly to validate the templates and instances and lastly, expanding the templates.

\para
Lutra parsing transforms the templates and instances written in the two serialisations into objects. Hence, classes for terms and types in Lutra already exist, which we can utilise in the Frog implementation due to OTTR and Frog using the same type and term system. We argue that utilising the same classes will make OTTR and Frog more seamless. Furthermore, both the parsing considering wOTTR and stOTTR utilises two different technologies. Firstly, wOTTR uses Jena. Jena or Apache Jena is a framework built for integrating Semantic Web and Linked Data technologies and applications in Java. Including parsing RDF data in different serialisations and executing SPARQL queries\cite{apache_jena}. Secondly, stOTTR uses ANTLR v4\footnote{\url{https://www.antlr.org}}. ANTLR v4 is a library made to describe grammar formally and translate the grammar into parsing code which is both executable and human-readable\cite{antlr4Book}. ANTLR does, in addition, produce error messages if the templates or instances are not compatible with the grammar. The grammar describing templates and instances in the stOTTR serialisation can be found in the sTOTTR documentation\cite{OTTR_stOTTR}.

\para
Lutra performs validation on the objects produced by the parsing by conducting several queries on the objects. Furthermore, Lutra's own defined queries engines describe the queries. However, Frog will not use the queries engines, as we will discuss in section \ref{implValidation}; therefore, we will not go in-depth on the validation part of Lutra. 

\para
TODO: something about expansion. 

\subsection{Result}

\section{Parser}
\label{parser}
As formerly mentioned, the parsing step in Lutra's Frog implementation consists of transforming the function found in an RDF syntax or HRS document into function objects. Lutra has already created the terms and types classes\footnote{Term and Type are interfaces in the implementation; however, we have drawn them as classes} before the introduction of Frog, except the terms and types introduced by Frog, such as functionCall, which we have introduced into Lutra. Figure \ref{fig:FunctionClassDiagram} illustrates the classes involved when creating a function object.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{FunctionClassDiagram.jpg}
  \caption{A UML diagram of a function. Note that this diagram has removed unnecessary connections and is a simplification of the actual code.}
  \label{fig:FunctionClassDiagram}
\end{figure}

\para 
Furthermore, constructing the objects introduced to Lutra when introducing Frog consists of two phases:
\begin{enumerate}
  \item Retrieve the data from the Frog document
  \item Using a builder\footnote{https://projectlombok.org/features/Builder} to create the objects that perform some basic validations, such that values are not null. 
\end{enumerate}
Due to Frog having two serialisations, the first phase has two implementations: one for the RDF syntax and one for the Human readable syntax. Section X and Y discuss the implementation of phase one for RDF syntax and HRS separately. Moreover, the second phase consists of constructing the objects by utilising a builder. Every class has a separate builder, such as a ParameterBuilder that produces parameter objects, which produces the objects and performs basic validation. We argue that performing validation in phase two of the parsing is more beneficial than phase one because phase two has one implementation compared to phase one with two implementations, resulting in less repetitive code. 

\para
The validation performed by the parsing step must not be mistaken with the validation discussed in section \ref{designValidation}. The discussion on the implementation of section \ref{designValidation} can be found in section \ref{implValidation}. Moreover, the validation performed in section \ref{designValidation} needs the context of the function library, such as checking that the function exists. On the other hand, validation performed in the parsing step only needs the object's context. For instance, validating that a function does not contain two parameters with the same variable name. 

\para
Figure \ref{fig:parserFlow} illustrates a general interaction between one of the parsers from phase one and the builder from phase two. In addition to showing the relationship between a builder and the subsequent class. As we see from the figure, the builder checks that every mandatory argument needed to create the class is present before creating the object. Thereafter, if present, the builder calls the validate method on the object. 

\begin{figure}
  \centering
  \includegraphics[scale=0.6]{parserFlow.jpg}
  \caption{A sequent diagram showing the general interaction between a parser, builder and class. }
  \label{fig:parserFlow}
\end{figure}

\subsection{RDF Syntex}
\label{implRDF}

\subsection{Human Readable Syntax}
\label{implHRS}
\subsubsection{Technologie}
We will utilise ANTLR v4 to define the grammar of Frog functions and function calls, precisely as with OTTR.  Due to the Human Readable-Syntax(HRS) of Frog inheriting the syntax of terms and stOTTR applying ANTLR v4 lets us reuse some of the grammar specifications and the code from the stOTTR part of the Lutra implementation. 

\subsubsection{Grammar}
One advantage of Frog utilising the same terms and types as OTTR is using the declared ANTLR v4 grammar from stOTTR. In ANTLR, we can reuse previously defined grammar by importing them. Hence, the start of the Frog grammar file will consist of specifying the name of the grammar for this file, namely Frog, and that we should import the parsing rules from stOTTR. 

\para
\lstinputlisting[language=antlr, firstline = 1, lastline = 3]{examples/implementation/Frog.g4}


\para
However, before we continue to depict the Frog grammar, we will define the changes to the stOTTR that the inclusion of Frog has provoked. As previously discussed, Frog introduces one new type, namely the Function type. In stOTTR, the grammar defines the function type by the keyword Function continued with arguments representing the parameter types and return type.

\para
\lstinputlisting[language=antlr, firstline = 110, lastline = 120]{examples/implementation/stOTTR.g4}

\para
Furthermore, Frog introduces two new terms to OTTR: the function term and the function call. However, the syntax for a function term is equivalent to an IRI term; consequently, the function term does not change grammar since the distinction between an IRI term and a function term is semantic. On the other side, the function call introduces a new term in OTTR, which we need to define in the stOTTR grammar. A function call is built-up as a list surrounded by round brackets \backgroundText{( )} and space separating the elements. Furthermore, a function call consists of an optional function call definition, the function name, the generic terms, and an arbitrary number of terms. The generic arguments are surrounded by two angle brackets on each side \backgroundText{<< >>} and an arbitrary number of generic variables, such as a variable or a type.

\para
\lstinputlisting[language=antlr, firstline = 141, lastline = 165]{examples/implementation/stOTTR.g4}


\para
The Frog grammar can continue now that the stOTTR grammar has defined the new terms and types. A document containing HRS function definition can, as stOTTR, include an arbitrary number of RDF prefixes and base declaration, as defined by the Turtle(KILDE) serialisation of RDF, which the grammar formally names directives. In addition to directives, the HRS Frog document can also contain any number of functions.  

\para
\lstinputlisting[language=antlr, firstline = 5, lastline = 8]{examples/implementation/Frog.g4}

\para
A Frog function consists of a function head and a function body. The function body is, as earlier mentioned, a function call; consequently, the function body uses the parsing rule for the function call defined in the stOTTR grammar. On the contrary, the function head needs to define the parsing rules in the Frog grammar and consists of a definition, generic parameters, parameters and a return type. The definition consists of the token \backgroundText{def} and the name of the function. Furthermore, the generic parameters are defined as a variable, the token subtype and a type, and are separated with a comma and surrounded with angular brackets on each side, \backgroundText{<< >>}. Moreover, the Frog HRS grammar depicts parameters as a type followed by a variable and are separated with a comma and surrounded with round brackets on each side \backgroundText{( )}. Lastly, the return type consists of the token \backgroundText{->} and a type. The function head and function body are divided by the token \backgroundText{::}.

\para
\lstinputlisting[language=antlr, firstline = 10, lastline = 48]{examples/implementation/Frog.g4}

\para
Lastly, the Frog grammar needs to redefine what a type is by including the generic type in addition to redefining the LUB-type, such that the LUB-type can accept a generic type as an argument and not only a basic type. In ANTLR v4, we can override parsers rules from the imported grammar. ANTLR will always utilise the parser rule defined by the rules defined in the Frog rather than the rule defined in the stOTTR grammar.

\para
\lstinputlisting[language=antlr, firstline = 51, lastline = 66]{examples/implementation/Frog.g4}

\para 
Admittedly, we could have defined a new parsing rule named frogType which could either be a type or a genericVariable. However, by overwriting the type parsing rule type in the Frog grammar, we avoid defining the list and function type again in the Frog grammar.

\subsubsection{From grammer to objects}
As mentioned, ANTLR4 generates classes and objects based on the defined Frog grammar, which Lutra utilises to parse the function document into function objects. ANTLR turns the document provided into a parse-tree and offers two different techniques for traversing the parsing three, namely parse-tree listeners and parse-tree visitors. Figure \ref{fig:parse_tree_example} is an example of a parsing three produced by ANTLR. Lutra's OTTR implementation utilises the visitor method for traversing the parsing tree. When expanding Lutra with the addition of Frog, it is beneficial to apply the same method since we can reuse the code written for Lutra's stOTTR parsing in the parsing of the HRS of Frog. 

\para
ANTLR's visitor technique lets us control the traversing by explicitly calling methods to visit children(KILDE antlr book). From Figure \ref{fig:parse_tree_example}, the functionHead's children are definition, genericParameter, parameters and returnType. ANTRL generates a base visitor class with an interface containing one visit method for each parsing rule in the grammar to perform the traversing. In the Frog grammar case, ANTLR generates a class FrogBaseVisitor that offers methods like visitParameter and visitFunction. However, the base visitor implementation of the visit methods only contains one action, to visit the children. Hence, we have made parser classes in Lutra that expand the FrogBaseVisitor and override the methods to define the method and create an object of the belonging class. For instance, example \ref{parameterParser} shows the class FParameterVisitor containing the method visitParameter since a parameter consists of a type and a variable. A parameter has two children a variable: a variable, which is a term, and a type. Hence the visitParameter needs to use the term and type parser to parse the children.

\begin{figure}
  \begin{example}
      \label{parameterParser}
      An example of a parser class, this parser class i the parser for a parameter. The FBaseParserVisitor class extends the FrogBaseVisitor, wrapping the generic argument into a result class (class FBaseParserVisitor<T> extends FrogBaseVisitor<Result< T > >).  
  \end{example}
  \lstinputlisting[language=java, firstnumber = 1, basicstyle=\small]{examples/implementation/FParameterParser.java}
\end{figure}

\para
Notably, Lutra already contains several parsing classes and visitor methods due to the stOTTR implementation, such as visitList and visitListType. Consequently, the addition of Frog resulted in expanding some of the parsing classes made for stOTTR, such as introducing a visitFunctionType method to the type parser class, in addition to introducing parsing classes for the Frog function-specific objects, such as function and generic parameters. 


\begin{figure}
  \centering
  \includegraphics[scale=0.23]{antlr4_parse_tree_example.png}
  \caption{The generated parser-tree made by ANTLR4s java implementation on the function in figure \ref{fig:generic_function}}
  \label{fig:parse_tree_example}
\end{figure}

\section{Validation}
\label{implValidation}
This section presents the implementation of the validation elaborated on in Section X. Note that Lutra only performs the validation on the frog function if Lutra completes the parsing stem without producing messages with severity degree Error or higher. Furthermore, as figure Y illustrates, Lutra executes the validation in three phases, and a phase is only executed if the previous phases are performed without any validations errors. Note that we have moved the implementation of step 6, which checks that the function has the correct return type. In short, we had to move step 6 in the implementation due to limitations in the desired technology, namely SPARQL. Section X discusses why this move is inevitable.

\subsection{Technology}
As mentioned, Lutra utilises a custom created queries engine built-in Java made to perform validation on OTTR templates and instances. Hence, when working with validation and OTTR, one must learn this custom created query engine. However, we argue that using established technologies compared to Lutra's custom created queries is more beneficial for several reasons. 

\para
Before stating the benefits, we need to specify what established technology we argue for, namely SPARQL, and why we propose that SPARQL is an established technology. Section X introduces SPARQL and describes that SPARQL is a query language over linked data structured by RDF. Furthermore, SPARQL is the standard language to perform queries and extract data from RDF documents, as stated by Mosser et al.\cite[1]{MosserSPARQL} and Peréz er al\cite[1]{PerezSPARQL}. Additionally, the W3C has endorsed SPARQL as a W3C document. Hence, we argue that SPARQL is an established semantic technology. 

\para
Furthermore, we assume that the users of OTTR are knowledgeable regarding the well-establish semantic technology; due to OTTR being a language offering tools to represent semantic technologies, such as RDF and OWL, through modelling patterns[KILDE: OTTR]. Consequently, we consider SPARQL to be a known technology for OTTR users. 

\para
Now that we have introduced SPARQL as an established semantic technology and known to OTTR users. We will proceed with arguing why we believe that conducting validation through SPARQL queries is beneficial. Firstly, applying SPARQL queries results in Frog validation leveraging the existing W3C. In addition, the SPARQL validation queries formally describe and specify Frog's validation. Similarly to how SHACL shapes define the OTTR wOTTR serialisation and the Frog RDF serialisation. Secondly, the users of OTTR can understand the validation straight from the validation queries due to SPARQL being a comprehended technology. Lastly, we argue the Frog benefits for that the validation using SPARQL queries are relatively easy to maintain due to SPARQL being a well-established and documented technology. Furthermore, we do not need to know about Lutra's implementation to change and update the queries because the SPARQL files are separate from the implementation. Consequently, updating the validations later will only require the programmer to know about SPARQL queries and the special RDF serialisation in isolation.

\para
However, performing all the validation in SPARQL has proven impracticable due to the incapacity to conduct recursive queries with SPARQL language\cite[711]{RecursionSPARQL}. We argue that recursive queries are beneficial when validating that one type is compatible with another type due to the recursive manner in which OTTR and Frog define the function type and list type and the recursive definition of compatibility on these types. Consequently, all the validation regarding compatible typing and subtyping, namely validating right return type, argument types and generic argument types, needs to be validated in a recursive manner. Reuter et al. discuss recursion in SPARQL and propose a recursive linear operator, which they implemented as an extension of the Jena\cite[732]{RecursionSPARQL}. Nevertheless, implementing this extension on top of Jena in Lutra is out of scope for this thises. An effort to perform the validation mentioned above with SPARQL through property paths and a complex representation of types in the RDF syntax. However, attempting to make these queries was not sufficient. 

\para
Consequently, Lutra is limited to utilising java implementation for the validation depending on types. We then made three simple recursive methods in the validation function. As illustrated by figure X, we considered these methods moderately uncomplicated. Hence, we have leveraged SPARQL and Jena's SPARQL implementation as far as technically possible and use relatively simple java methods where applying SPARQL is proven to be complicated. We argue that the benefits mentioned regarding SPARQL, such as getting a formal definition of the validations being easy to maintain and understand for a user of OTTR, are more substantial compared to Lutra's query engine. Although we only leverage in parts of the validations. 

\subsection{Validation Flow}

\subsection{SPARQL}

\subsection{Java}

\section{Evaluation}
\label{implementation_evaluation}

\subsection{Memorisation}
\textbf{NB: tatt fra design delen men ble overflødig og handlet plutselig mer om implementasjonen. Deler kan brukes til dette kampittelet}
\\
When determining whether to use memorisation or not, we have to consider the advantages and disadvantages of utilising memorisation in the context of Frog. On the one hand, memorisation will assumably reduce Frog's time to evaluate the function calls. On the other hand, utilising memorisation in Frog will increase the amount of storage needed. In addition, performing a lookup in the lookup table takes in worst-case O(n)(KILDE) when utilising a hash table. Hence, the lookup time should be less than the time used to evaluate the function call. Consequently, we present two criteria we belives needs to fulfil for memorisation in the context of Frog to be beneficial:
\begin{enumerate}
    \item The assumed time used to perform a lookup should be assumed to be less than the time used to perform the function call.
    \item The assumed storage space needed for memorisation in Frog should be considered not to be remarkably high. 
\end{enumerate}

\para 
Before discussing if Frog should use memorisation, we will introduce two new concepts: function call signature and function call description. 
Firstly, a function call signature is the function name combined with the arguments. Note that the generic arguments are not a part of a function call signature. Hence the function call (fn:plus<<xsd:decimal>> 5 6) and (fn:plus<<xsd:integer>> 5 6) will have a equal function call signature. Secondly, in contrast to the function call signature, the function call description contains the generic arguments, the function name and arguments. Thus the function call (fn:plus<<xsd:decimal>> 5 6) and (fn:plus<<xsd:integer>> 5 6) will not have the same function call description.

\para
To further discuss if memorisation satisfies the two criteria, we must present a possible solution to accomplish memorisation in Frog. Two function calls the same function call signature will evaluate the same value since Frog performs the same calculations on the same arguments. However, function calls with different function call definitions may not have the same type on the evaluated value due to the use of generics. For instance, the function ex:plus2 from figure X will have a different return type which Frog must determine from the generic argument ?t. Hence, the function call (plus2<<xsd:decimal>> 5)  would evaluate to \lstinline{15^^xsd:decimal} while (plus2<<xsd:integer>> 5) would evaluate to \lstinline{15^^xsd:integer}. As illustrated, the evaluated value of two function call with an equal function call signature will be equal. However, the function call description may change the return value type.

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{simpleHash.jpg}
      \caption{A generalisation of the lookup table when only considering the function call signature}
      \label{fig:simpleHash}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{lookUpGeneral.jpg}
      \caption{A generlaisation of the lookup table consdiering the function call signature and definition}
      \label{fig:lookUpGeneral}
    \end{minipage}
\end{figure}

\para
Thus, a table consisting of the function call signature and the result value will not be enough as it may result in Frog evaluating the value of a not approved type. Evaluating the function call (plus2<<xsd:decimal>> 5) would result in the lookup table shown in figure X. When trying to evaluate (plus2<<xsd:integer>> 5) afterwards Frog will utilise the lookup table since the function call signature is present; however this will result in Frog evaluating the function call to be \lstinline{15^^xsd:decimal}, which is not a valid value. Therefore, we present a solution in which Frog first checks if the function call signature is present and afterwards checks if the function call definition is present. Figure Y illustrates the general structure, while figure Z shows an instance containing the examples mentioned. 

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{lookUpAfterFirst.jpg}
      \caption{Example lookup table only considering the function call signature}
      \label{fig:lookUpAfterFirst}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[scale=0.35]{exampelFulllookuptable.jpg}
      \caption{Example lookup table considering the function call signature and defintion}
      \label{fig:exampelFulllookuptable}
    \end{minipage}
\end{figure}

\section{Executor}

\section{Changes in OTTR}

